{"meta":{"title":"狐の小屋","subtitle":"","description":"","author":"Mythe","url":"http://mythe51.github.io","root":"/"},"pages":[{"title":"about","date":"2022-04-21T07:50:35.000Z","updated":"2022-04-21T07:50:35.756Z","comments":true,"path":"about/index.html","permalink":"http://mythe51.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-07-22T14:03:24.000Z","updated":"2022-07-22T14:03:42.869Z","comments":false,"path":"categories/index.html","permalink":"http://mythe51.github.io/categories/index.html","excerpt":"","text":""},{"title":"投喂","date":"2022-04-21T15:11:06.000Z","updated":"2022-04-22T03:10:00.345Z","comments":false,"path":"donate/index.html","permalink":"http://mythe51.github.io/donate/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-21T15:11:06.000Z","updated":"2022-04-24T04:02:02.861Z","comments":true,"path":"link/index.html","permalink":"http://mythe51.github.io/link/index.html","excerpt":"","text":""},{"title":"nanatoserver","date":"2022-04-23T09:24:17.000Z","updated":"2022-04-23T09:24:18.019Z","comments":true,"path":"nanatoserver/index.html","permalink":"http://mythe51.github.io/nanatoserver/index.html","excerpt":"","text":""},{"title":"music","date":"2022-04-22T01:39:11.000Z","updated":"2022-04-22T01:39:11.929Z","comments":true,"path":"music/index.html","permalink":"http://mythe51.github.io/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-11T04:42:36.352Z","updated":"2022-05-11T04:42:36.352Z","comments":true,"path":"shuoshuo/shuoshuo.css","permalink":"http://mythe51.github.io/shuoshuo/shuoshuo.css","excerpt":"","text":"#shuoshuo_content { background-color: #fff; padding: 10px; min-height: 500px; } /* shuo */ body.theme-dark .cbp_tmtimeline::before { background: RGBA(255, 255, 255, 0.06); } ul.cbp_tmtimeline { padding: 0; } div class.cdp_tmlabel > li .cbp_tmlabel { margin-bottom: 0; } .cbp_tmtimeline { margin: 30px 0 0 0; padding: 0; list-style: none; position: relative; } /* The line */ .cbp_tmtimeline:before { content: ''; position: absolute; top: 0; bottom: 0; width: 4px; background: RGBA(0, 0, 0, 0.02); left: 80px; margin-left: 10px; } /* The date/time */ .cbp_tmtimeline > li .cbp_tmtime { display: block; /* width: 29%; */ /* padding-right: 110px; */ max-width: 70px; position: absolute; } .cbp_tmtimeline > li .cbp_tmtime span { display: block; text-align: right; } .cbp_tmtimeline > li .cbp_tmtime span:first-child { font-size: 0.9em; color: #bdd0db; } .cbp_tmtimeline > li .cbp_tmtime span:last-child { font-size: 1.2em; color: #9BCD9B; } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmtime span:last-child { color: RGBA(255, 125, 73, 0.75); } div.cbp_tmlabel > p { margin-bottom: 0; } /* Right content */ .cbp_tmtimeline > li .cbp_tmlabel { margin: 0 0 45px 65px; background: #9BCD9B; color: #fff; padding: .8em 1.2em .4em 1.2em; /* font-size: 1.2em; */ font-weight: 300; line-height: 1.4; position: relative; border-radius: 5px; transition: all 0.3s ease 0s; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); cursor: pointer; display: block; } .cbp_tmlabel:hover { /* transform:scale(1.05); */ transform: translateY(-3px); z-index: 1; box-shadow: 0 15px 32px rgba(0, 0, 0, 0.15) !important } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmlabel { background: RGBA(255, 125, 73, 0.75); } /* The triangle */ .cbp_tmtimeline > li .cbp_tmlabel:after { right: 100%; border: solid transparent; content: \" \"; height: 0; width: 0; position: absolute; pointer-events: none; border-right-color: #9BCD9B; border-width: 10px; top: 4px; } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmlabel:after { border-right-color: RGBA(255, 125, 73, 0.75); } p.shuoshuo_time { margin-top: 10px; border-top: 1px dashed #fff; padding-top: 5px; } /* Media */ @media screen and (max-width: 65.375em) { .cbp_tmtimeline > li .cbp_tmtime span:last-child { font-size: 1.2em; } } .shuoshuo_author_img img { border: 1px solid #ddd; padding: 2px; float: left; border-radius: 64px; transition: all 1.0s; } .avatar { border-radius: 100% !important; -moz-border-radius: 100% !important; box-shadow: inset 0 -1px 0 3333sf; -webkit-box-shadow: inset 0 -1px 0 3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; -moz-transition: -moz-transform 0.4s ease-out; } .zhuan { transform: rotateZ(720deg); -webkit-transform: rotateZ(720deg); -moz-transform: rotateZ(720deg); } /* end */"},{"title":"shuoshuo","date":"2022-05-11T04:42:41.021Z","updated":"2022-05-11T04:42:41.021Z","comments":false,"path":"shuoshuo/index.html","permalink":"http://mythe51.github.io/shuoshuo/index.html","excerpt":"","text":"第一个说说 2020年2月25日 (function () { var oldClass = \"\"; var Obj = \"\"; $(\".cbp_tmtimeline li\").hover(function () { Obj = $(this).children(\".shuoshuo_author_img\"); Obj = Obj.children(\"img\"); oldClass = Obj.attr(\"class\"); var newClass = oldClass + \" zhuan\"; Obj.attr(\"class\", newClass); }, function () { Obj.attr(\"class\", oldClass); }) })"},{"title":"tags","date":"2022-07-22T13:50:46.000Z","updated":"2022-07-22T13:51:24.627Z","comments":false,"path":"tags/index.html","permalink":"http://mythe51.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"插入排序","slug":"插入排序","date":"2022-08-18T03:21:21.000Z","updated":"2022-08-18T03:39:53.539Z","comments":true,"path":"2022/08/18/插入排序/","link":"","permalink":"http://mythe51.github.io/2022/08/18/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"根据王道书上的代码，结合自己的理解，写的插入排序的代码，分为直接插入排序和希尔排序两个。 直接插入排序 直接插入排序的思想是将每一个元素插入到已经有序的序列中，使其仍然保持有序。在实际代码处理的时候，胸第二个元素开始处理，将前面的序列看成有序，实现原地排序的效果。 直接插入排序的空间复杂度为O(1)，且为稳定的排序算法。 直接插入排序的最好时间复杂度为O(n)，最坏时间复杂度为O(n2)，平均时间复杂度为O(n2) # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; # include &lt;time.h&gt; # define LENGTH 10 void CreateList(int * data, int len) &#123; int i = 0; srand(time(NULL)); for (i=0; i&lt;len; i++) &#123; data[i] = rand() % 100; &#125; return; &#125; void PrintList(int * data, int len) &#123; int i = 0; for (i=0; i&lt;len; i++) &#123; printf(\"%d \", data[i]); &#125; printf(\"\\n\"); return; &#125; // 直接插入排序 void InsertSort(int * data /* 待处理的数据 */, int len /* 数据的长度 */) &#123; int i = 0; for (i=1; i&lt;len; i++) &#123; // 从第二个数据开始处理 int j = i - 1; if (data[i] &lt; data[i - 1]) &#123; // 如果前面的序列存在比当前数值大的数 int temp = data[i]; while (j &gt;= 0 &amp;&amp; data[j] &gt; temp) &#123; // 一路往前把大的数向后移 data[j + 1] = data[j]; j--; &#125; data[j + 1] = temp; &#125; printf(\"%2d th sort: \", i); PrintList(data, len); &#125; return; &#125; int main(void) &#123; int * data = (int *)malloc(sizeof(int) * LENGTH); CreateList(data, LENGTH); printf(\"Before sort: \"); PrintList(data, LENGTH); InsertSort(data, LENGTH); printf(\"After sort: \"); PrintList(data, LENGTH); return 0; &#125; 希尔排序 希尔排序是直接插入排序的一种优化。其核心思想为： 将间隔为d的元素取出来看成一个新的子序列 对子序列进行直接插入排序，这样会使得原序列相对有序 不断缩小d的值，直到d等于1，此时希尔排序退化为直接插入排序 因为希尔排序每一次的排序都是建立在之前相对有序的基础上，所以能相对提高效率。 直接插入排序的空间复杂度为O(1)，且为不稳定的排序算法。 在增量序列函数选取合适的前提下，希尔排序的时间复杂度为O(n1.3)，最坏情况下的时间复杂度为O（n2）。 # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; # include &lt;time.h&gt; # define LENGTH 15 void CreateList(int * data, int len) &#123; int i = 0; srand(time(NULL)); for (i=0; i&lt;len; i++) &#123; data[i] = rand() % 100; &#125; return; &#125; void PrintList(int * data, int len) &#123; int i = 0; for (i=0; i&lt;len; i++) &#123; printf(\"%d \", data[i]); &#125; printf(\"\\n\"); return; &#125; // 希尔排序 void ShellSort(int * data, int len) &#123; int d = 0; int i = 0; for (d=len/2; d&gt;=1; d/=2) &#123; // 设置步长，初始值为元素个数的一半，最后的值为1 for (i=d; i&lt;len; i++) &#123; // 在规定的步长内对元素进行直接插入排序 if (data[i] &lt; data[i - d]) &#123; int temp = data[i]; int j = i - d; while (j &gt;= 0 &amp;&amp; data[j] &gt; temp) &#123; data[j + d] = data[j]; j = j - d; &#125; data[j + d] = temp; &#125; &#125; printf(\"d = %d: \", d); PrintList(data, len); &#125; return; &#125; int main(void) &#123; int * data = (int *)malloc(sizeof(int) * LENGTH); CreateList(data, LENGTH); printf(\"Before sort: \"); PrintList(data, LENGTH); ShellSort(data, LENGTH); printf(\"After sort: \"); PrintList(data, LENGTH); return 0; &#125;","categories":[{"name":"数据结构 - 排序","slug":"数据结构-排序","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"一个红包引发的惨案","slug":"一个红包引发的惨案","date":"2022-08-15T09:06:04.000Z","updated":"2022-08-15T09:27:54.668Z","comments":true,"path":"2022/08/15/一个红包引发的惨案/","link":"","permalink":"http://mythe51.github.io/2022/08/15/%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/","excerpt":"","text":"一个红包引发的惨案 故事起源于隔壁一个吹水群的某天中午，可能是想增加点乐趣，群主发了两个红包。恰好是一笔画红包。而一笔画红包涉及到数据结构图论的相关知识，所以在此进行总结，并贴出相关的代码。 简介 一笔画红包 一笔画红包是QQ红包的一种形式。挑战者需要完成一笔画挑战之后才能领取红包 欧拉图 欧拉图是一种特殊的图，定义如下： 欧拉图是指通过图（无向图或有向图）中所有边且每边仅通过一次通路，相应的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。 对于欧拉图，有以下几条性质： 一个无向图存在欧拉回路，当且仅当该图有 0 个或 2 个奇数度数的顶点，且该图是连通图。 一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数，且该图是连通图。 一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。 一个有向图存在欧拉回路：图连通，所有节点的出度等于入度；或者除两个节点以外的其余节点的入度和出度都相等，且这两个节点一个满足出度 - 入度 ==1，另一个满足入度 – 出度 ==1。 对于QQ红包的场景，明显其为有向图。如果我们能获取到每条边的信息，就能使用深度优先算法求解欧拉路径。理论存在，实践开始 实践 获取边的信息 获取边的信息很简单，直接手机代理链接电脑上的fiddler，开启抓包即可。 右下角就是TX返回的包体了。connects数组包含了所有的边，而vertexes保存了所有的顶点。 对包体进行处理 这里使用了python对包进行处理，将包体的字符串变成我们熟悉的邻接矩阵： # 构建邻接矩阵 def PreProcess(package): global versum package = package.replace(\"\\\\\", \"\") package = package.replace(\"\\\"[\", \"[\") package = package.replace(\"]\\\"\", \"]\") package = json.loads(package)['data'] # 到这里为止是字符串的预处理 con = package['connects'] for i in con: sx = (i['x1'] - 75) / 150 sy = (i['y1'] - 75) / 150 ex = (i['x2'] - 75) / 150 ey = (i['y2'] - 75) / 150 # 根据像素计算顶点序号 s = int(sy * 5 + sx) e = int(ey * 5 + ex) versum = versum + 1 # 统计边的条数 m[s][e] = m[s][e] + 1 # 设置邻接矩阵 计算起始顶点和终止顶点 根据欧拉图的性质，对于任意一个合法的欧拉图，只可能出现两种情况： 有2个奇数度的顶点，此时这两个奇数度的顶点分别为起点和终点 没有奇数度的顶点，此时任意一个顶点都能作为起点和终点 根据性质，写出代码即可 求解欧拉路径 这里使用深度优先算法。欧拉图可能有多解，选择其中的一个解即可： # now 的初始调用值为上面确定的起点 def DFS(now): for i in range(25): if m[now][i] == 1: m[now][i] = m[now][i] - 1 DFS(i) path.append(now + 1) 完整代码 下面是完整代码： import json m = [[0 for j in range(25)] for i in range(25)] s = 0 e = 0 versum = 0 path = [] # 构建邻接矩阵 def PreProcess(package): global versum package = package.replace(\"\\\\\", \"\") package = package.replace(\"\\\"[\", \"[\") package = package.replace(\"]\\\"\", \"]\") print(package) package = json.loads(package)['data'] print(package[\"vertexes\"]) con = package['connects'] for i in con: sx = (i['x1'] - 75) / 150 sy = (i['y1'] - 75) / 150 ex = (i['x2'] - 75) / 150 ey = (i['y2'] - 75) / 150 s = int(sy * 5 + sx) e = int(ey * 5 + ex) versum = versum + 1 m[s][e] = m[s][e] + 1 # 判断起始和终止点 def GetStartAndEnd(): global s, e du = [] se = [] for i in range(25): t = sum(m[i]) t = t + sum([m[j][i] for j in range(25)]) du.append(t) print(\"顶点的度：\", du) for i in du: if i % 2 == 1: se.append(du.index(i)) if len(se) == 0: for i in du: if 1 != 0: se.append(du.index(i)) se.append(du.index(i)) break s = se[0] e = se[1] def DFS(now): for i in range(25): if m[now][i] == 1: m[now][i] = m[now][i] - 1 DFS(i) path.append(now + 1) pass if __name__ == '__main__': package = input(\"input package: \\n\") PreProcess(package) print(\"邻接矩阵：\") for i in range(25): print(m[i]) GetStartAndEnd() print(\"以下为分析结果：\\n\") print('起点：', s + 1, '终点：', e + 1, '边数：', versum) DFS(s) path.reverse() print(\"参考路径：\") for i in range(len(path)): print(path[i], end=' ') if (i+1) % 5 == 0: print() 运行截图： 希望能通过这个小小的例子，体会欧拉图在生活中的应用。","categories":[{"name":"数据结构 - 图-欧拉图","slug":"数据结构-图-欧拉图","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E6%AC%A7%E6%8B%89%E5%9B%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"构建一棵平衡二叉树","slug":"构建一棵平衡二叉树","date":"2022-08-04T14:14:02.000Z","updated":"2022-08-05T06:15:08.866Z","comments":true,"path":"2022/08/04/构建一棵平衡二叉树/","link":"","permalink":"http://mythe51.github.io/2022/08/04/%E6%9E%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"本篇从代码和图形两部分，深层次理解平衡二叉树的构造。 基本概念 首先给出二叉树节点的定义，以下均使用该处定义的节点类型： typedef struct avlnode &#123; int data; // 数据域 int height; // 以该节点为根的树的高度 struct avlnode * parent; // 父节点指针 struct avlnode * lchild; // 左孩子指针 struct avlnode * rchild; // 右孩子指针 &#125;Node, *AVLNode; 平衡二叉树是一种特殊的二叉排序树。既然是二叉排序树，就必须满足二叉排序树的性质： 所有左子树节点的值 &lt; 根节点的值 &lt; 所有右子树节点的值 对于一棵二叉排序树，我们在插入的时候只需要简单的寻找其插入位置，然后将其插入即可。代码表示如下： AVLNode pt = AVLTree; while(pt != NULL) &#123; if (pt-&gt;data &gt; val) &#123; pt = pt-&gt;lchild; &#125; else &#123; pt = pt-&gt;rchild; &#125; &#125; 根据此代码，pt最后停留的位置，就是新节点应该插入的位置。实际在写代码的时候肯定不会这样简单，因为单单有pt的位置还不能插入一个节点，需要有pt的父节点和插入节点相对于父节点的路径。这里不再赘述。 平衡二叉树和二叉树相比，引入了“平衡因子”这个概念，用来表示左右子树的高度之差。即： 平衡因子 = 左子树高度 - 右子树高度 // 计算平衡因子 int CalcBF(AVLNode node) &#123; if (node == NULL) &#123; return 0; // 空节点的平衡因子为0 &#125; int bf = 0; if (node-&gt;lchild != NULL) &#123; bf = bf + node-&gt;lchild-&gt;height; &#125; if (node-&gt;rchild != NULL) &#123; bf = bf - node-&gt;rchild-&gt;height; &#125; // bf = 0 + 左子树高度 - 右子树高度 = 左子树高度 - 右子树高度，这样做能尽量减少判断次数， return bf; &#125; 这里没加绝对值，表示平衡因子有正有负。事实上，平衡因子的正负反映了左右子树的高低关系：为正，表示左子树高于右子树；为负，表示右子树高于左子树。 基本操作–左旋和右旋 平衡二叉树规定，任意节点的平衡因子的绝对值不能超过1（即只能有0和1两种可能）。超过1就需要进行调整。调整只针对最小不平衡子树。以下介绍调整的两种方式：左旋，右旋。 左旋 左旋是使用右子树替代根的一种做法。如图所示： 在代码实现时，分为以下三步： 使用原根的右子树代替根的位置 将新根的左子树（如果存在）挂在原根的右子树上 将原根挂在新根的左子树上 以上步骤不可颠倒。完成之后，即可在实现原来根的右子树替换根的同时，不破坏左子树小于根小于右子树的原则。 以下是代码实现，代码中有详细的注解。 // 左旋 void lRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;rchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的左子树挂载到oldroot的右子树 oldroot-&gt;rchild = newroot-&gt;lchild; if (newroot-&gt;lchild != NULL) &#123; // 一定要加以判断，否则可能会产生访问错误 newroot-&gt;lchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;lchild = oldroot; oldroot-&gt;parent = newroot; // 这一步是防止传进来的参数本身就是根节点的情况 // 如果传进来的参数是根节点，就修改根节点指针指向的值，因为根节点没有父节点，无法通过修改父子节点的关系进行修改。 node = newroot; &#125; 右旋 右旋和左旋类似，是使用左子树替换根节点，同时保持二叉排序树特性不变的操作。直接上代码 // 右旋，这里使用了引用类型作为参数，方便修改 void rRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;lchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的右子树挂载到oldroot的左子树 oldroot-&gt;lchild = newroot-&gt;rchild; if (newroot-&gt;rchild != NULL) &#123; newroot-&gt;rchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;rchild = oldroot; oldroot-&gt;parent = newroot; node = newroot; &#125; 四种不平衡类型 有四种可能出现的导致不平衡的情形，分别是LL，RR，LR和RL（直接使用网图，懒得画了）： 这四种类型是根据新添加的节点相对于最小不平衡子树的位置而定的。例如，新添加的节点相对于最小不平衡子树的根节点，在左子树的右子树里，则为LR型。 LL型和RR型 LL型和RR型相对简单，只需要进行右旋和左旋即可，如图： LR型和RL型 这两种相对比较复杂，需要两步操作才能降低平衡因子。其核心思想是用最下面的节点，经过两次调整，替代原来的根节点，如图： 代码实现AVL树的生成 # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; typedef struct avlnode &#123; int data; // 数据域 int height; // 相对高度 struct avlnode * parent; // 父节点 struct avlnode * lchild; // 左孩子 struct avlnode * rchild; // 右孩子 &#125;Node, *AVLNode; // 计算相对高度，这里如果递归，必须使用后序递归，为什么？ void CalcHeight(AVLNode node) &#123; AVLNode pt = node; if (pt == NULL) &#123; return; &#125; CalcHeight(pt-&gt;lchild); CalcHeight(pt-&gt;rchild); int l = 1; int r = 1; if (node-&gt;lchild != NULL) &#123; l = node-&gt;lchild-&gt;height + 1; &#125; if (node-&gt;rchild != NULL) &#123; r = node-&gt;rchild-&gt;height + 1; &#125; node-&gt;height = l &gt; r ? l : r; &#125; // 计算平衡因子 int CalcBF(AVLNode node) &#123; if (node == NULL) &#123; return 0; &#125; int bf = 0; if (node-&gt;lchild != NULL) &#123; bf = bf + node-&gt;lchild-&gt;height; &#125; if (node-&gt;rchild != NULL) &#123; bf = bf - node-&gt;rchild-&gt;height; &#125; return bf; &#125; // 右旋 void rRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;lchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的右子树挂载到oldroot的左子树 oldroot-&gt;lchild = newroot-&gt;rchild; if (newroot-&gt;rchild != NULL) &#123; newroot-&gt;rchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;rchild = oldroot; oldroot-&gt;parent = newroot; node = newroot; &#125; // 左旋 void lRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;rchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的左子树挂载到oldroot的右子树 oldroot-&gt;rchild = newroot-&gt;lchild; if (newroot-&gt;lchild != NULL) &#123; newroot-&gt;lchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;lchild = oldroot; oldroot-&gt;parent = newroot; node = newroot; &#125; void InsertNode(AVLNode &amp; AVLTree, int val) &#123; AVLNode pnew = (AVLNode)malloc(sizeof(Node)); pnew-&gt;data = val; pnew-&gt;lchild = pnew-&gt;rchild = pnew-&gt;parent = NULL; // 如果是空树，将该节点设为根节点，结束 if (AVLTree == NULL) &#123; AVLTree = pnew; return; &#125; // 非空树，先寻找插入的位置 AVLNode pt = AVLTree; AVLNode pp; int way = 0; while(pt != NULL) &#123; pp = pt; if (pt-&gt;data &gt; val) &#123; way = 0; pt = pt-&gt;lchild; &#125; else &#123; way = 1; pt = pt-&gt;rchild; &#125; &#125; pnew-&gt;parent = pp; if (way == 0) &#123; pp-&gt;lchild = pnew; &#125; else &#123; pp-&gt;rchild = pnew; &#125; CalcHeight(AVLTree); // 尝试找到最小的不平衡子树 pt = pnew; while (pt-&gt;parent != NULL) &#123; pt = pt-&gt;parent; if (CalcBF(pt) == 2) &#123; if (CalcBF(pt-&gt;lchild) == -1) &#123; lRotate(pt-&gt;lchild); &#125; if (pt == AVLTree) &#123; rRotate(AVLTree); &#125; else &#123; rRotate(pt); &#125; break; &#125; if (CalcBF(pt) == -2) &#123; if (CalcBF(pt-&gt;rchild) == 1) &#123; rRotate(pt-&gt;rchild); &#125; if (pt == AVLTree) &#123; lRotate(AVLTree); &#125; else &#123; lRotate(pt); &#125; break; &#125; &#125; CalcHeight(AVLTree); return; &#125; void PrintTree(AVLNode AVLTree) &#123; AVLNode pt = AVLTree; if (pt == NULL) &#123; return; &#125; PrintTree(pt-&gt;lchild); printf(\"%d %d\\n\", pt-&gt;data, pt-&gt;height); PrintTree(pt-&gt;rchild); &#125; int main(void) &#123; AVLNode Tree = NULL; int n = 0; int i = 0; int t = 0; scanf(\"%d\", &amp;n); for (i=0; i&lt;n; i++) &#123; scanf(\"%d\", &amp;t); InsertNode(Tree, t); &#125; PrintTree(Tree); return 0; &#125; 运行结果（上图为程序运行结果，下图为根据输入序列得到的二叉平衡树示意图）：","categories":[{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"记一次被骗经历","slug":"记一次被骗经历","date":"2022-07-27T07:32:11.000Z","updated":"2022-07-27T07:36:23.462Z","comments":true,"path":"2022/07/27/记一次被骗经历/","link":"","permalink":"http://mythe51.github.io/2022/07/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97%E7%BB%8F%E5%8E%86/","excerpt":"","text":"记一次被骗经历 这并不是什么光彩的事，我知道。但是我还是想把它写出来，并放在一个（相对）比较显眼的位置，希望能对后来的人有所帮助。毕竟这样的学费交一次就够了。本篇文章会分为三个部分：被骗；发觉被骗以及追回被骗的钱。 0x01 医院门口的“偶遇” 那是7月24日的下午六点，我刚从医院出来。 当我正打算扫一辆单车回家的时候，有人向我搭话。大概的意思就是门店在做宣传投票，希望我能帮忙投其中的一个门店。 因为当时并不涉及金钱问题，加上投票只需要微信上简单操作即可。我就扫了当时他们提供的二维码，进入了投票页面。投票页面由于没有截图，就不放出来了。 投票之后，那个人提出投票可以参与免费的抽奖。当时觉得自己反正也不可能中，就抽了。出乎人意料的是，中了。页面显示“名牌手机名额一个”。 当时我觉得很不可思议，包括在场的工作人员也表现的很“不可思议”。提出“你的手气也太好了吧”，“如果真的领上了能不能请我们喝红牛”之类的话。我多次询问领取奖品是否需要支付额外的费用，他们都说不用。然后我就上了老板的电动车，到了店里。 — 在店里 — 在店里，工作人员先是简单的核实了一下我的抽奖是否是真实的。当然，速度很快，快到我不可思议（也就是几秒钟的时间就核实好了）。然后就说这个是真实的。 紧接着，他们和我核实了以下信息： 年满18周岁 是否是第一次参加店里的活动 芝麻信用分是否达到600分 全部核实完毕之后，他们向我展示了奖品——oppo a95（5G 8+256）/联想平板二选一。说实话，看到手机的时候我就觉得这个手机不咋地。但是多少也值点钱，如果将这个手机出二手还是能卖一点钱的。所以当时我选择要手机。 这时，重点来了。 他们给我打印好了活动的申请单。并且说，这是他们店正在搞的一个推广活动。现在主营线下的家用电器和手表（通过翻看宣传册得知手表均在1000元以上）。线上的app入驻的商家比较少。如果参加活动，需要给线上的app充值4999元（之后了解了我是学生，说只需要4000元即可）。 充值的钱会进入账户的“兑换余额”和“抵扣余额”，有以下几种消费方式： 线下店购买商品时，按照商品进行等额扣除 线上app有兑换商城，可以在兑换商城里兑换商品进行消费 线上app的“拼多多”，“京东”入口，可以使用余额部分抵扣商品原价，用户只需支付差价。 如果只进行到这个阶段，我肯定会因为身上没有5000块钱而选择放弃。然后就是第二个重点：不支持一次结清，只支持分期付款。并且给出了两种分期付款方案： 在未来的十年内，每个月到店结算当期账单（约40元每月） 使用花呗，借呗，京东白条或者其他分期付款软件，根据自己的信用额度选择分期时长（最长为2年，约每月140元） 以上两条是写在申请单上面的。之后还做出了口头约定（当然，同样不具备法律效力）。如： 店家承诺分期付款产生的利息由他们承担 店家承诺会帮我“套现”，即如果有人在实体店购买商品却不是会员，他们可以帮我将账户里的余额变现。 当时店里的音响声音被故意的开得很大。我觉得应该不是因为那些人喜欢音乐。 口头承诺的第二条让我有点心动。在之后我还是问了能不能再次降低套餐。工作人员“进行了请示”之后回复说，“手机的价值就接近2000，没办法再降低套餐了”，我便同意了。 （以下是签的协议文本） 在办理的时候，查了花呗借呗的额度均不足4000元，之后选择了乐花卡这个软件。这个软件利率相当之高，年化利率达到了24，而且还有其他的服务费之类。但是工作人员承诺会承担借贷利息。 这里有一个小插曲。在借贷时，因为操作失误，多借了一笔，也就是一共借了8000元。工作人员谎称是我的哥哥，帮我打客服，客服回应可以帮助解锁账单，2小时之后就可以提前还。（为之后埋下伏笔） 下载APP时，我首先在应用市场里面搜索。店家说，他们这个app只在IOS上架，未在安卓平台上架，要求我扫描他们提供的二维码下载。我不死心，百度搜索app名字，居然没搜到这个关键字。半信半疑中，扫描了他们提供的二维码下载了他们提供的app。 临走时，店家还“贴心”的送了一个充电宝，说是“本来是首次消费送的，就直接给你了”，估计是也没指望我来这里消费。 0x02 迟到的后知后觉 当天晚上回到家，我一夜没睡着。 想来想去，我也想不通为什么一定要让我使用分期软件进行支付。打开刚刚下载的“智家潮品”APP，启动图做的很烂，属于是一看就知道是次品的那种。简单浏览，发现里面可以兑换的商品种类还是很多的，就没有再理。 第二天（7月25日），我将手机挂在了咸鱼上，出价1300元（该配置的手机原价为1600元）。 当天第一个和我咨询的人重重的打了我一记大棒。 当时他和我讲价，我说1200元不包邮已经是底线，他也同意了，甚至已经付款了。但是最后，他提出要看看手机的激活日期。我当时的第一反应是，卧槽，还有这玩意？ 我开始搜索这个激活日期代表的含义。原来，安卓手机在首次联网开机的时候会被激活。这个激活时间是官方售后保修的依据。现实给了我一拳。因为官网显示这个手机早在2021年的5月就被激活，现在已经过保。 换句话说，这个手机早在一年前就被人联网使用过，很可能是退换机。这时候我开始意识到问题不对劲。想找店家要个说法： 这个时候感觉自己是被骗了。因为如果手机有这种情况的话，其他的电器也很可能会有类似的情况。花原价的钱，买到的已经是二手机器了。这时候我第一次意识到自己被骗了。 晚上，我和小A说我被骗了。被骂了一顿之后，我提出能不能把他那边的消费放到这个app上，帮我分担一点。他问了两样东西，一个是薯片，一个是可乐。 在那之后，我仔细的看了上面的食品类商品。发现里面虽然种类比较多，但是大多是不知名的小牌子，而且完全没有售后保障，也就是说，如果买到了临期或者过期的食品，只能自认倒霉。 与此同时，我将这个情况和小C（为什么不用B这个字母呢？因为觉得B这个字母不太好）说了，小C当即断定我被骗了。在了解到有分期付款的情况后，建议我直接报案。 经过一晚上的梳理，大致整理出以下几条不合理的地方： 诱导进行贷款消费 根据协议“注意事项”，主动退出需只能退还70%的金额，剩余金额在APP内无法取出，但是这笔钱扣除的没有根据。 作为赠品的手机非原装，提前一年就被使用过 第二天，当我和店家沟通，提出想看看原来的申请书和告知函时，被告知文件原版已经在签字当天被粉碎。更加印证了被骗的想法。 0x03 还算顺利的维权 此时是7月26日，距离被骗已经过去了两天。 下午两点，在和小C进行过充分的商量之后，我到了离我最近的辖区派出所。在和警察详细讲述了当时的情况之后，警察也一时没法分辨我是否已经被骗。因为此时还未到对方尽义务的时间，和我提出，要不就到被骗地点附近的派出所问问，要不就先等一个月。我选择了前者。 骑一辆单车，走了三公里，到了另一个派出所。 那个派出所的警察在听了我讲的之后，说当天在我之前已经有一个人有过同样的情况，让我去辖区的市监局（就在马路对面）。当时还是很高兴的，因为人越多代表这个事越容易解决。 在市监局门口站了一小会，有个人问我是不是举报智家潮品的，我说是，就进了办公室。 办公室里，那家店的老板已经在里面了，（接下来又是一顿被教育之后）现场办理了退款。在退款的时候，老板反复说“学生嘛，你和工作人员说就会全部给你退掉啦”之类的，我也反复说“我已经问过了，就是要预留百分之三十，所以我才来的”，大无语。 之所以不是3999，时因为当时收钱的时候就扣掉了前三个月的利息。我也表示如果能把当时收的前全部退还，分期付的利息我可以自己承担。就这样，只花了十几分钟就解决了问题，可喜可贺。 回家的路上，我和乐花卡的客服进行了沟通。客服在得知我是因为被骗借款之后，同意提前解锁订单还款。两小时之后成功还款，共计还款4012元。 还款之后，我将乐花卡，借呗，花呗，京东白条的账户全部注销，这件事情至此告一段落。 0x04 后记 从市监局出来之后，我在门口站了几分钟整理目前的信息。然后遇到了和我一样被骗的小D，我们在感叹自己是大冤种的同时，也从头到尾梳理了整次事件比较关键的细节点。 专挑独狼。因为多人很可能会被身边人提醒从而发现骗局 看你善良就会多捅几刀。对方正是利用助人为乐的心理，从而行骗 这次事件从头到尾我只交了16块钱的学费，但是间接的损失不可估量。包括对心理产生的影响以及两天没好好吃饭睡觉。刚开始发觉这是骗局的时候，心里是很无助的。但是经过和朋友沟通（对，没找家长）之后。。还是很无助（）。 总之，希望我的经历能给更多的人起到警示作用，虽然最后并没有直接损害很多，但是也仅仅是偶然情况，下一次肯定就不止这点损失了。","categories":[{"name":"杂记","slug":"杂记","permalink":"http://mythe51.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]},{"title":"顺序查找","slug":"顺序查找","date":"2022-07-23T12:42:11.000Z","updated":"2022-07-23T12:48:25.837Z","comments":true,"path":"2022/07/23/顺序查找/","link":"","permalink":"http://mythe51.github.io/2022/07/23/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/","excerpt":"","text":"根据王道教材编写的顺序查找的代码。顺序查找的思路比较简洁，但是需要注意哨兵的使用方法。 /* 时间：2022年7月23日20:42:30 作者：Mythe 根据王道书上的代码，写的顺序查找的示例。 在本例中注意理解哨兵的作用。 哨兵不能让程序运行更快，但是能简化思考的逻辑，减少if语句的使用。 */ # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; # include &lt;time.h&gt; typedef struct &#123; int * elem; int length; &#125;L, *SeqList; // 顺序查找 int SeqSearch(SeqList L, int key) &#123; int i = L-&gt;length - 1; // 初始指针指向末尾 L-&gt;elem[0] = key; // 0号位置放哨兵 while (L-&gt;elem[i] != key) &#123; // 即使待查找的表里面没有指定关键字，也必定会在0号位置找到指定关键字 i--; // 从后往前依次找 &#125; return i - 1; // 返回非-1的数表示查找成功，否则查找失败 &#125; // 填充数据 void InitList(SeqList L) &#123; srand(time(NULL)); L-&gt;length = 1; L-&gt;elem = (int *)malloc(sizeof(int) * 11); L-&gt;elem[0] = 0; // 第一个位置为无效数据 int i = 0; for (i=0; i&lt;10; i++) &#123; L-&gt;elem[L-&gt;length] = rand() % 100; L-&gt;length++; &#125; &#125; // 导出数据 void PrintList(SeqList L) &#123; int i = 0; for (i=1; i&lt;L-&gt;length; i++) &#123; printf(\"%d \", L-&gt;elem[i]); &#125; printf(\"\\n\"); &#125; int main(void) &#123; int key = 0; SeqList L = (SeqList)malloc(sizeof(SeqList)); InitList(L); printf(\"------ 顺序查找演示程序 ------\\n待查找数组：\"); PrintList(L); printf(\"输入要查找的关键字：\"); scanf(\"%d\", &amp;key); printf(\"您查找的关键字所在的数组下标为%d\\n若数组下标为-1则查找失败。\\n\", SeqSearch(L, key)); return 0; &#125; 运行截图：","categories":[{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"折半查找","slug":"折半查找","date":"2022-07-22T13:16:37.000Z","updated":"2022-07-23T14:04:46.685Z","comments":true,"path":"2022/07/22/折半查找/","link":"","permalink":"http://mythe51.github.io/2022/07/22/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/","excerpt":"","text":"根据王道教材编写的折半查找的示例代码。 折半查找的题目示例： P2249 /* 时间：2022年7月22日21:06:51 作者：Mythe 根据王道书上的代码，写的折半查找的示例代码。 */ # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; typedef struct List &#123; int * data; int length; &#125;List, *SeqList; // 将数据初始化为从0到1000 void InitList(SeqList L) &#123; L-&gt;data = (int *)malloc(sizeof(int) * 1001); L-&gt;length = 0; int i = 0; for (i=0; i&lt;1000; i++) &#123; L-&gt;data[L-&gt;length] = i + 1; L-&gt;length++; &#125; return; &#125; int BinarySearch(SeqList L, int key) &#123; int i = 0; int low = 0, high = L-&gt;length - 1; int middle = 0; while (low &lt;= high) &#123; middle = (low + high) / 2; // 计算middle的值为两者中心 int val = L-&gt;data[middle]; printf(\"第%2d次比较，low=%3d，high=%3d，middle=%3d，数值：%3d，结果：\", i++, low, high, middle, L-&gt;data[middle]); if (val &lt; key) &#123; low = middle + 1; // 如果给定的值比当前中心位置大，则让low指针指向middle的下一个位置 &#125; else if (val &gt; key) &#123; high = middle - 1; // 如果给定的值比当前中心位置小，则让high指针指向middle的上一个位置 &#125; else &#123; printf(\"成功。\\n\"); return middle; &#125; printf(\"失败。\\n\"); &#125; // 当low的值大于high的值时，while循环退出，此时说明没有查找到目标的值，返回-1。 return -1; &#125; int main(void) &#123; int key; SeqList L = (SeqList)malloc(sizeof(List)); printf(\"----- 折半查找演示程序 ------\\n\"); printf(\"顺序表存放1-1000之间的整数，请输入你要查找的数：\"); InitList(L); scanf(\"%d\", &amp;key); printf(\"index = %d\\n\", BinarySearch(L, key)); return 0; &#125; 运行截图：","categories":[{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"米游社api相关","slug":"米游社api相关","date":"2022-05-09T11:00:00.000Z","updated":"2022-05-11T04:03:23.236Z","comments":true,"path":"2022/05/09/米游社api相关/","link":"","permalink":"http://mythe51.github.io/2022/05/09/%E7%B1%B3%E6%B8%B8%E7%A4%BEapi%E7%9B%B8%E5%85%B3/","excerpt":"","text":"请求规范（请求头） 字段 说明 参考值（无特殊需求可以照抄） x-rpc-app_version 米游社app版本 2.11.1 User-Agent UA字段 Mozilla/5.0 AppleWebKit/605.1.15 (KHTML, like Gecko) miHoYoBBS/2.11.1 x-rpc-client_type 客户端类型 5 Referer Referer字段 https://webstatic.mihoyo.com/ Cookie 米游社Cookie 浏览器登录米游社，F12找到控制台，输入&quot;document.cookie&quot;回车即可，如下图 DS 动态密钥 生成方法如下 动态密钥 动态密钥由3部分构成，最后一部分是一个MD5。MD5的输入由5个部分构成，按照如下格式进行组合： data = f&quot;salt=&#123;CN_DS_SALT&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;&quot; 参数说明： 参数 含义 CN_DS_SALT 盐，在当前版本的米游社app里这个值是“xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs” t 时间戳 r 一个从100000到200000的随机数 b POST请求的数据，需要将字典对象序列化 q GET请求的数据，形如&quot;aaa=aaa&amp;bbb=bbb&amp;ccc=ccc&quot; 伪代码如下： data = &quot;salt=&#123;CN_DS_SALT&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;&quot; md5data = md5(data) DS = &quot;&#123;t&#125;,&#123;r&#125;,&#123;h&#125;&quot; 给出两种实现方式： python（@heartalborada） CN_DS_SALT = 'xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs' def generate_cn_ds(body = None, query = None) -&gt; str: ''' Body: POST请求 query: GET请求 ''' t = int(time.time()) r = random.randint(100001, 200000) b = json.dumps(body) if body else \"\" q = \"&amp;\".join(f\"&#123;k&#125;=&#123;v&#125;\" for k, v in sorted(query.items())) if query else \"\" h = hashlib.md5(f\"salt=&#123;CN_DS_SALT&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;\".encode()).hexdigest() return f\"&#123;t&#125;,&#123;r&#125;,&#123;h&#125;\" C#（@DGP-Studio） using Snap.Data.Json; using Snap.Data.Utility; using System; using System.Linq; public class DynamicSecretProvider2 : Md5Converter &#123; private static readonly string APISalt = \"xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs\"; public static string Create(string queryUrl, object? postBody = null) &#123; long t = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); string r = GetRandomString(); string b = postBody is null ? \"\" : Json.Stringify(postBody); string q = \"\"; string[] urlParts = queryUrl.Split('?'); if (urlParts.Length == 2) &#123; string[] queryParams = urlParts[1].Split('&amp;').OrderBy(x =&gt; x).ToArray(); q = string.Join(\"&amp;\", queryParams); &#125; string check = GetComputedMd5($\"salt=&#123;APISalt&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;\"); return $\"&#123;t&#125;,&#123;r&#125;,&#123;check&#125;\"; &#125; private static readonly Random random = new(); private static string GetRandomString() &#123; return random.Next(100000, 200000).ToString(); &#125; &#125; API UID 查询玩家基本信息 url：https://api-takumi-record.mihoyo.com/game_record/app/genshin/api/index 请求方式：GET 传入字段 说明 值 role_id 玩家UID 如“100010000” server 玩家所在服务器 “cn_gf01”国服官服，“cn_qd01”国服B服 获取角色武器和圣遗物 url：https://api-takumi-record.mihoyo.com/game_record/app/genshin/api/character 请求方式：POST 传入字段 说明 值 character_ids 要查询的角色id 传入空数组即可，即 []，可获取全部角色 role_id 玩家UID 如“100010000” server 玩家所在服务器 “cn_gf01”国服官服，“cn_qd01”国服B服 获取档期和上期角色数据 url：https://api-takumi-record.mihoyo.com/game_record/app/genshin/api/spiralAbyss 请求方式：GET 传入字段 说明 值 role_id 玩家UID 如“100010000” server 玩家所在服务器 “cn_gf01”国服官服，“cn_qd01”国服B服 schedule_type 档期类型 “1”为本期，“2”为上期","categories":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/categories/%E9%BB%98%E8%AE%A4/"}],"tags":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]},{"title":"abccc","slug":"abccc","date":"2022-04-21T07:25:36.000Z","updated":"2022-04-21T07:26:47.606Z","comments":true,"path":"2022/04/21/abccc/","link":"","permalink":"http://mythe51.github.io/2022/04/21/abccc/","excerpt":"","text":"this is a test blog","categories":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/categories/%E9%BB%98%E8%AE%A4/"}],"tags":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-21T04:50:44.934Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/04/21/hello-world/","link":"","permalink":"http://mythe51.github.io/2022/04/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"数据结构 - 排序","slug":"数据结构-排序","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"},{"name":"数据结构 - 图-欧拉图","slug":"数据结构-图-欧拉图","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E6%AC%A7%E6%8B%89%E5%9B%BE/"},{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"},{"name":"杂记","slug":"杂记","permalink":"http://mythe51.github.io/categories/%E6%9D%82%E8%AE%B0/"},{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/categories/%E9%BB%98%E8%AE%A4/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"},{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]}