{"meta":{"title":"狐の小屋","subtitle":"","description":"","author":"Mythe","url":"http://mythe51.github.io","root":"/"},"pages":[{"title":"about","date":"2022-04-21T07:50:35.000Z","updated":"2022-04-21T07:50:35.756Z","comments":true,"path":"about/index.html","permalink":"http://mythe51.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-07-22T14:03:24.000Z","updated":"2022-07-22T14:03:42.869Z","comments":false,"path":"categories/index.html","permalink":"http://mythe51.github.io/categories/index.html","excerpt":"","text":""},{"title":"投喂","date":"2022-04-21T15:11:06.000Z","updated":"2022-04-22T03:10:00.345Z","comments":false,"path":"donate/index.html","permalink":"http://mythe51.github.io/donate/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-04-21T15:11:06.000Z","updated":"2022-04-24T04:02:02.861Z","comments":true,"path":"link/index.html","permalink":"http://mythe51.github.io/link/index.html","excerpt":"","text":""},{"title":"nanatoserver","date":"2022-04-23T09:24:17.000Z","updated":"2022-04-23T09:24:18.019Z","comments":true,"path":"nanatoserver/index.html","permalink":"http://mythe51.github.io/nanatoserver/index.html","excerpt":"","text":""},{"title":"music","date":"2022-04-22T01:39:11.000Z","updated":"2022-04-22T01:39:11.929Z","comments":true,"path":"music/index.html","permalink":"http://mythe51.github.io/music/index.html","excerpt":"","text":""},{"title":"","date":"2022-05-11T04:42:36.352Z","updated":"2022-05-11T04:42:36.352Z","comments":true,"path":"shuoshuo/shuoshuo.css","permalink":"http://mythe51.github.io/shuoshuo/shuoshuo.css","excerpt":"","text":"#shuoshuo_content { background-color: #fff; padding: 10px; min-height: 500px; } /* shuo */ body.theme-dark .cbp_tmtimeline::before { background: RGBA(255, 255, 255, 0.06); } ul.cbp_tmtimeline { padding: 0; } div class.cdp_tmlabel > li .cbp_tmlabel { margin-bottom: 0; } .cbp_tmtimeline { margin: 30px 0 0 0; padding: 0; list-style: none; position: relative; } /* The line */ .cbp_tmtimeline:before { content: ''; position: absolute; top: 0; bottom: 0; width: 4px; background: RGBA(0, 0, 0, 0.02); left: 80px; margin-left: 10px; } /* The date/time */ .cbp_tmtimeline > li .cbp_tmtime { display: block; /* width: 29%; */ /* padding-right: 110px; */ max-width: 70px; position: absolute; } .cbp_tmtimeline > li .cbp_tmtime span { display: block; text-align: right; } .cbp_tmtimeline > li .cbp_tmtime span:first-child { font-size: 0.9em; color: #bdd0db; } .cbp_tmtimeline > li .cbp_tmtime span:last-child { font-size: 1.2em; color: #9BCD9B; } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmtime span:last-child { color: RGBA(255, 125, 73, 0.75); } div.cbp_tmlabel > p { margin-bottom: 0; } /* Right content */ .cbp_tmtimeline > li .cbp_tmlabel { margin: 0 0 45px 65px; background: #9BCD9B; color: #fff; padding: .8em 1.2em .4em 1.2em; /* font-size: 1.2em; */ font-weight: 300; line-height: 1.4; position: relative; border-radius: 5px; transition: all 0.3s ease 0s; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.15); cursor: pointer; display: block; } .cbp_tmlabel:hover { /* transform:scale(1.05); */ transform: translateY(-3px); z-index: 1; box-shadow: 0 15px 32px rgba(0, 0, 0, 0.15) !important } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmlabel { background: RGBA(255, 125, 73, 0.75); } /* The triangle */ .cbp_tmtimeline > li .cbp_tmlabel:after { right: 100%; border: solid transparent; content: \" \"; height: 0; width: 0; position: absolute; pointer-events: none; border-right-color: #9BCD9B; border-width: 10px; top: 4px; } .cbp_tmtimeline > li:nth-child(odd) .cbp_tmlabel:after { border-right-color: RGBA(255, 125, 73, 0.75); } p.shuoshuo_time { margin-top: 10px; border-top: 1px dashed #fff; padding-top: 5px; } /* Media */ @media screen and (max-width: 65.375em) { .cbp_tmtimeline > li .cbp_tmtime span:last-child { font-size: 1.2em; } } .shuoshuo_author_img img { border: 1px solid #ddd; padding: 2px; float: left; border-radius: 64px; transition: all 1.0s; } .avatar { border-radius: 100% !important; -moz-border-radius: 100% !important; box-shadow: inset 0 -1px 0 3333sf; -webkit-box-shadow: inset 0 -1px 0 3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; -moz-transition: -moz-transform 0.4s ease-out; } .zhuan { transform: rotateZ(720deg); -webkit-transform: rotateZ(720deg); -moz-transform: rotateZ(720deg); } /* end */"},{"title":"shuoshuo","date":"2022-05-11T04:42:41.021Z","updated":"2022-05-11T04:42:41.021Z","comments":false,"path":"shuoshuo/index.html","permalink":"http://mythe51.github.io/shuoshuo/index.html","excerpt":"","text":"第一个说说 2020年2月25日 (function () { var oldClass = \"\"; var Obj = \"\"; $(\".cbp_tmtimeline li\").hover(function () { Obj = $(this).children(\".shuoshuo_author_img\"); Obj = Obj.children(\"img\"); oldClass = Obj.attr(\"class\"); var newClass = oldClass + \" zhuan\"; Obj.attr(\"class\", newClass); }, function () { Obj.attr(\"class\", oldClass); }) })"},{"title":"tags","date":"2022-07-22T13:50:46.000Z","updated":"2022-07-22T13:51:24.627Z","comments":false,"path":"tags/index.html","permalink":"http://mythe51.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"两种指令系统","slug":"两种指令系统","date":"2022-09-18T03:14:33.000Z","updated":"2022-09-18T03:20:26.195Z","comments":true,"path":"2022/09/18/两种指令系统/","link":"","permalink":"http://mythe51.github.io/2022/09/18/%E4%B8%A4%E7%A7%8D%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"CISC和RISC CISC RISC 指令系统 复杂、庞大 简单、精炼 指令数目 一般大于200条 一般小于100条 指令字长 不固定 定长 可访存指令 不加限制 只有Load和Store指令 指令执行时间 相差很大 绝大多数在一个周期内完成 指令使用频度 相差很大 都较常用 通用寄存器数量 较少 多 目标代码 难以是用优化编译产生高效的目标代码 采用优化的编译程序，生成的代码较高效 控制方式 绝大多数为微程序控制 绝大多数为组合逻辑控制 指令流水线 可以通过一定方式实现 必须实现","categories":[{"name":"计算机组成原理 - 中央处理器","slug":"计算机组成原理-中央处理器","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"两种汇编格式","slug":"两种汇编格式","date":"2022-09-18T02:44:57.000Z","updated":"2022-09-18T02:53:59.975Z","comments":true,"path":"2022/09/18/两种汇编格式/","link":"","permalink":"http://mythe51.github.io/2022/09/18/%E4%B8%A4%E7%A7%8D%E6%B1%87%E7%BC%96%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"AT&amp;T格式和Intel格式 AT&amp;T格式 Intel格式 目的操作数d，源操作数s op s, d op d, s 寄存器的表示 mov %ebx, %eax mov eax, ebx 立即数的表示 mov $985, %eax mov eax, 985 主存地址的表示 mov %eax, (af996h) mov [af996h], eax 读写长度的表示 movb $5, (af996h)movw $5, (af996h)movl $5, (af996h)addb $5, (af996h) mov byte ptr [af996h], 5mov word ptr [af996h], 5mov dword ptr [af996h], 5add byte ptr [af996h], 5 主存地址偏移量的表示 movl -8(%ebx), %eaxmovl 4(%ebx, %ecx, 32), %eax mov eax, [ebx - 8]mov eax, [ebx + ecx * 32 + 4]","categories":[{"name":"计算机组成原理 - 中央处理器","slug":"计算机组成原理-中央处理器","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"数据在计算机的表示","slug":"数据在计算机的表示","date":"2022-09-03T02:39:54.000Z","updated":"2022-09-06T03:45:18.455Z","comments":true,"path":"2022/09/03/数据在计算机的表示/","link":"","permalink":"http://mythe51.github.io/2022/09/03/%E6%95%B0%E6%8D%AE%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"二进制的表示 整数的表示 表示范围(n+1位二进制) 最大的数 最小的数 0的表示 无符号整数 $ 0 \\leq x \\leq 2^{n+1}-1 $ 1111 1111 0000 0000 0000 0000 原码 $ -(2^n-1) \\leq x \\leq 2^n-1 $ 0111 1111 1111 1111 0000 00001000 0000 反码 $ -(2^n-1) \\leq x \\leq 2^n-1 $ 0111 1111 1000 0000 0000 00001111 1111 补码 $ -(2^n) \\leq x \\leq 2^n-1 $ 0111 1111 1000 0000 0000 0000 移码 $ -(2^n) \\leq x \\leq 2^n-1 $ 1111 1111 0000 0000 1000 0000 定点小数的表示 表示范围(n+1位二进制) 最大的数 最大的数 0的表示 原码 $ -(1-2^{-n}) \\leq x \\leq 1-2^{-n} $ 0111 1111 1111 1111 0000 00001000 0000 反码 $ -(1-2^{-n}) \\leq x \\leq 1-2^{-n} $ 0111 1111 1000 0000 0000 00001111 1111 补码 $ -1 \\leq x \\leq 1-2^{-n} $ 0111 1111 1000 0000 0000 0000 硬件运算 标志位 OF（Overflow Flag) 含义：有符号数加减运算是否发生了溢出，当OF=1时，发生了溢出 计算方法：OF = 最高位产生的进位 异或 次高位产生的进位 对计算方法的理解： 溢出只可能有两种情况，即 两个正数相加发生溢出 两个负数相加发生溢出 对于第一种情况，两个操作数的最高位都应该是0，但是相加之后变成了1，未发生进位 对于第二种情况，两个操作数的最高位都应该是1，但是相加之后变成了0，未发生进位 这个模型刚好可以使用异或模型进行刻画。 SF（Signal Flag） 含义：有符号数加减运算结果的正负，SF为0表示正，SF为1表示负 计算方法：SF = 最高位的本位和 对计算方法的理解：运算结果的最高位 ZF 含义：标识运算结果是否为0，ZF = 1表示运算结果为0 硬件的计算方法：当运算结果的n位bit全部为0时，ZF = 1 CF 进位/借位标志，标识无符号数的加减法是否发生了进位或者借位，当CF = 1时，发生了进位或者借位，即发生了溢出 硬件的计算方法：CF = 最高位产生的进位 异或 sub，sub = 减法 ? 1 : 0 注意：OF和SF仅针对有符号数，CF仅针对无符号数，ZF既可以是有符号数也可以是无符号数。","categories":[{"name":"计算机组成原理 - 数据的表示和运算","slug":"计算机组成原理-数据的表示和运算","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"三种交换方式","slug":"三种交换方式","date":"2022-08-29T02:44:42.000Z","updated":"2022-08-29T03:08:24.915Z","comments":true,"path":"2022/08/29/三种交换方式/","link":"","permalink":"http://mythe51.github.io/2022/08/29/%E4%B8%89%E7%A7%8D%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F/","excerpt":"","text":"三种交换方式 交换方式 优点 缺点 电路交换 通信时延小有序传输没有冲突，不会争用物理信道适用范围广，模拟信号和数字信号都可以控制简单 建立连接时延长线路独占，使用效率低灵活性差，不适用于紧急通信；线路中任意一点故障都需要重新建立线路难以规格化，双方收发能力不同时很难通信，难以差错控制 报文交换 无需建立连接动态分配线路提高了线路可靠性，一个点坏了可以找其他的路径提高了线路利用率提供多目标服务，一个报文可以同时发给多目标 需要中间设备存储，会有处理时延和排队时延报文交换队报文的长度没有限制，需要中间设备有足够大的缓存空间 分组交换 无需建立连接线路利用率高简化了存储管理加速传输，不同分组可以并行的传输在网络上减少了出错概率，即使出错重发的数据量也较少 存在处理时延和排队时延需要传输额外的控制信息可能会出现失序，丢失或重复分组等问题 分组交换的两种实现方式 数据报 发送分组前不需要建立连接，随时，随地 数据报方式无连接，不能保证可靠性，会出现分组丢失失序等问题 每个分组都要包含完整的源地址和目的地址 分组再通过中间设备时会有处理时延和排队时延，甚至可能会被丢弃 网络有冗余路径，对故障的适应能力强 收发双方不独占某条线路，资源利用率高 虚电路 连接的建立和拆除需要时间开销 虚电路的传输路径是固定的，一旦某点出现故障，需要重新建立线路 虚电路保证了时序，并且可以进行流量控制 数据报 虚电路 连接的建立 不需要 需要 目的地址 每个分组有完整的源地址和目的地址 仅在建立连接时使用，连接建立完成之后使用虚电路号 路由选择 每个分组独立的进行路由选择和转发 属于同一虚电路的分组按照同样的路径转发 分组顺序 不保证分组顺序 保证分组有序 可靠性 不保证可靠通信 可靠性由网络保证 对故障的适应性 当一个节点故障时，可以使用其他路径进行传输 锁油经过故障点的虚电路均无法工作 差错处理和流量控制 由用户进行流量控制，不保证可靠性 可由分组交换网负责，也可以由用户主机负责","categories":[{"name":"计算机网络 - 计算机网络体系结构","slug":"计算机网络-计算机网络体系结构","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"作息时间表","slug":"作息时间表","date":"2022-08-28T13:54:45.000Z","updated":"2022-08-28T14:25:01.229Z","comments":true,"path":"2022/08/28/作息时间表/","link":"","permalink":"http://mythe51.github.io/2022/08/28/%E4%BD%9C%E6%81%AF%E6%97%B6%E9%97%B4%E8%A1%A8/","excerpt":"","text":"作息时间表（9-12月） 通常时段（非周六）作息时间 周六作息时间 时段 时间 内容 时长 时段 时间 内容 时长 早间 6:00 起床 - 上午 06:30-07:00 早餐 30 06:00-06:20 洗漱，打水等 20 07:00-07:45 第一节 45 06:30-06:50 运动（早间） 20 07:55-08:10 第二节 45 06:50-07:20 早读 30 08:50-09:35 第三节 45 07:30-08:15 第一节 45 09:45-10:30 第四节 45 08:15-08:35 早餐 20 10:40-12:00 自习 80 上午 08:35-09:20 第二节 45 09:35-10:20 第三节 45 下午 下午休息 10:30-11:15 第四节 45 11:25-12:10 自习 45 晚间 18:00-20:00 *** 120 20:00-21:00 自习1 60 午间 12:10-14:00 吃饭，午休 110 21:00-22:00 自习2 60 22:00-22:45 洗漱，夜宵等 45 下午 14:00 起床 - 22:45 就寝 - 14:20-15:05 第五节 45 15:15-16:00 第六节 45 （这里有内容被删掉了233） 16:20-17:05 第七节 45 17:15-18:00 自习 45 晚间 18:00-18:50 晚饭 50 18:50-19:40 自习1 100 19:40-20.30 自习2 20:40-21:30 自习3 100 21:30-22:20 自习4 22:20-22:45 洗漱，夜宵等 25 22:45 就寝 - function ChangeRowspanHiddenData() { var node; var params=[\"r1\",\"r3\",\"r9\",\"r12\",\"r16\",\"r18\",\"r21\",\"r22\",\"r24\"]; for (var i = 0;i < params.length; i++) { node = document.getElementById(params[i]); if (node != null) { node.style.display = \"\"; } } } ChangeRowspanHiddenData(); &lt;/body&gt;","categories":[{"name":"杂记","slug":"杂记","permalink":"http://mythe51.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]},{"title":"OSI七层模型表格记忆","slug":"OSI七层模型表格记忆","date":"2022-08-26T05:16:25.000Z","updated":"2022-08-26T05:18:05.300Z","comments":true,"path":"2022/08/26/OSI七层模型表格记忆/","link":"","permalink":"http://mythe51.github.io/2022/08/26/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%A1%A8%E6%A0%BC%E8%AE%B0%E5%BF%86/","excerpt":"","text":"OSI参考模型 层次 传输单位 作用 常用协议 应用层 - 用户与网络的界面 FTP, SMTP, HTTP等 表示层 - 数据格式转换数据加密解密数据压缩恢复 JPG, ASCII等 会话层 - 进程间会话的建立，管理和终止插入校验点实现断点续传 - 传输层 报文段（TCP）数据报（UDP） 流量控制差错控制服务质量数据传输管理复用和分用 TCP, UDP 网络层 数据报 路由选择流量控制拥塞控制差错控制网际互连 IP, ICMP, IGMP, ARP, OSPF等 数据链路层 帧 封装成帧差错控制流量控制传输管理控制对共享信道的访问 SDLC, HDLC, PPP 物理层 比特 定义接口特性定义传输模式定义传输速率比特同步，比特编码 - TCP/IP 模型","categories":[{"name":"计算机网络 - 计算机网络体系结构","slug":"计算机网络-计算机网络体系结构","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"选择排序","slug":"选择排序","date":"2022-08-20T05:38:12.000Z","updated":"2022-08-20T06:00:24.697Z","comments":true,"path":"2022/08/20/选择排序/","link":"","permalink":"http://mythe51.github.io/2022/08/20/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","excerpt":"","text":"根据王道书上的代码，结合自己的理解，编写的简单选择排序和堆排序（基于大根堆）的示例代码。 简单选择排序 简单选择排序的思想是，每次从未处理的数据里面选择一个最小的（或者最大的），将这个最小值（或者最大值）放在已排序数组的末尾，从而实现排序。 简单选择排序的时间复杂度不受初始排列的影响，始终为O(n^2) 简单选择排序的空间复杂度为常数级O(1) 简单选择排序是一种不稳定的排序算法，可能会改变相同元素的先后顺序。 示例代码： // 简单选择排序 void SelectSort(int * data, int len) &#123; int i = 0, j = 0; for (i=0; i&lt;len; i++) &#123; int min = i; // 最小值下标初始化为i for (j=i+1; j&lt;len; j++) &#123; // 从i+1开始 if (data[j] &lt; data[min]) &#123; min = j; // 确定后面最小的元素的下标 &#125; &#125; if (min != i) &#123; swap(data[min], data[i]); // 把后面最小的元素与第一位的元素交换 &#125; &#125; return; &#125; 堆排序 堆排序通过首先建立一个堆，每次从堆里面选择一个最大（或者最小）的元素，从而实现排序。 大根堆：二叉树的根节点大于所有子孙节点的二叉树。 小根堆：二叉树的根节点小于所有子孙节点的二叉树。 实现堆排序，首先要对数组进行原始处理，使得数组满足大根堆顺序存储的要求。 具体做法是，从数组的一半开始，倒着往前处理（因为数组后一半都是叶子节点，无需调整，而从后往前保证了每上一层的调整都基于下面已经满足大根堆要求的前提） // 将一个数组调整为大根堆 void CreateHeap(int * data, int len) &#123; int i = 0; for (i=len/2; i&gt;0; i--) &#123; AdjustHeap(data, i, len); // 明确为什么从后往前，因为按照二叉树的逻辑，应该是从下往上的 // 保证上面每一个节点的处理都是在下面节点合法的情况下 &#125; return; &#125; 这里面的核心操作是AdjustHeap函数。这个函数传入一个指定的节点，然后把这个节点下沉到属于它的位置： // 调整一个节点使其大于下面的所有节点，这个操作是堆排序的核心 void AdjustHeap(int * data, int k, int len) &#123; int i = 0; data[0] = data[k]; // 0号位置保存待安放的根节点 for (i=k*2; i&lt;=len; i*=2) &#123; if (i != len &amp;&amp; data[i] &lt; data[i+1]) &#123; // 判断根的两个孩子谁比较大，并将i指向更大的孩子 i++; &#125; if (data[0] &gt;= data[i]) &#123; // 如果根的值大于最大的孩子，就不需要调整了 break; &#125; data[k] = data[i]; // 将孩子的值上浮，但是没法确定根就放在这个孩子的位置 // 因为这个孩子的孩子还可能比原来的根大 k = i; // 将根节点转化为这个更大的孩子，在这个孩子的下面继续寻找 &#125; data[k] = data[0]; return; &#125; 一旦将一个树调整成大根堆，之后只需要懂哪个元素调整哪个元素即可，不足要再全部调整。 void HeapSort(int * data, int len) &#123; int i = 0; CreateHeap(data, len); // 初始化堆，时间复杂度O(n) for (i=len; i&gt;1; i--) &#123; // 共进行n轮操作 swap(data[1], data[i]); // 交换堆根节点元素和最后一个节点的元素 AdjustHeap(data, 1, i-1); // 对剩余的部分进行堆调整，注意数组的长度是i-1，时间复杂度是O(log2n) &#125; return; &#125; 上面代码的第六行需要特别注意。这个循环里面所做的事情有： 将当前的堆顶与最后一个元素交换 调整刚刚被换成堆顶的元素，使得堆顶仍然保持最大 这里需要注意循环内AdjustHeap函数的参数。 第二个参数，由于始终是对第一个元素进行调整，所以置1 第三个参数，只填未处理的元素的个数。在上一步交换之后，未处理的元素只剩下i-1个，所以这里填写i-1 这里的数组0号位不放元素，主要是基于数的顺序存储，从1号位开始存放元素，计算孩子节点更加方便。","categories":[{"name":"数据结构 - 排序","slug":"数据结构-排序","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"快速排序","slug":"快速排序","date":"2022-08-18T04:13:45.000Z","updated":"2022-08-18T04:22:40.873Z","comments":true,"path":"2022/08/18/快速排序/","link":"","permalink":"http://mythe51.github.io/2022/08/18/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","excerpt":"","text":"快速排序 根据王道书上的代码，对快速排序做整理。 快速排序的思想是： 使用双指针法，将第一个元素放在表中合适的位置，使得这个位置左面的元素都小于这个元素，右面的元素都大于等于这个元素。 递归的处理这个元素分割而成的两个子表，使得有序。 在编写相关的额代码的时候，一定一定一定要注意函数的退出条件和循环的退出条件 快速排序调用的深度和对应二叉树的深度相同。 快速排序的最好时间复杂度是O(log2n)，最坏时间复杂度是O(n^2) 快速排序的最好空间复杂度是O(log2n)，最坏空间复杂度是O(n) # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; # include &lt;time.h&gt; # define LENGTH 10 int i = 0; void CreateList(int * data, int len) &#123; int i = 0; srand(time(NULL)); for (i=0; i&lt;len; i++) &#123; data[i] = rand() % 100; &#125; return; &#125; void PrintList(int * data, int len) &#123; int i = 0; for (i=0; i&lt;len; i++) &#123; printf(\"%d \", data[i]); &#125; printf(\"\\n\"); return; &#125; // 将首元素放在合适的位置，返回放置的位置 int Partition(int * data, int low, int high) &#123; int middle = data[low]; // 提前将元素保存出来，防止覆盖 while (low &lt; high) &#123; while(low &lt; high &amp;&amp; data[high] &gt;= middle) &#123; // 注意每次移动指针都需要判断指针的关系 high--; &#125; data[low] = data[high]; while (low &lt; high &amp;&amp; data[low] &lt; middle) &#123; low++; &#125; data[high] = data[low]; &#125; data[low] = middle; return low; &#125; // 快速排序主函数 void QuickSort(int * data, int low, int high) &#123; if (low &lt; high) &#123; int middle = Partition(data, low, high); printf(\"%2d th sort: \", ++i); PrintList(data, LENGTH); QuickSort(data, low, middle - 1); // 左子序列 QuickSort(data, middle + 1, high); // 右子序列 &#125; return; &#125; int main(void) &#123; int * data = (int *)malloc(sizeof(int) * LENGTH); CreateList(data, LENGTH); printf(\"Before sort: \"); PrintList(data, LENGTH); QuickSort(data, 0, LENGTH - 1); printf(\"After sort: \"); PrintList(data, LENGTH); return 0; &#125;","categories":[{"name":"数据结构 - 排序","slug":"数据结构-排序","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"插入排序","slug":"插入排序","date":"2022-08-18T03:21:21.000Z","updated":"2022-08-18T03:39:53.539Z","comments":true,"path":"2022/08/18/插入排序/","link":"","permalink":"http://mythe51.github.io/2022/08/18/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","excerpt":"","text":"根据王道书上的代码，结合自己的理解，写的插入排序的代码，分为直接插入排序和希尔排序两个。 直接插入排序 直接插入排序的思想是将每一个元素插入到已经有序的序列中，使其仍然保持有序。在实际代码处理的时候，胸第二个元素开始处理，将前面的序列看成有序，实现原地排序的效果。 直接插入排序的空间复杂度为O(1)，且为稳定的排序算法。 直接插入排序的最好时间复杂度为O(n)，最坏时间复杂度为O(n2)，平均时间复杂度为O(n2) # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; # include &lt;time.h&gt; # define LENGTH 10 void CreateList(int * data, int len) &#123; int i = 0; srand(time(NULL)); for (i=0; i&lt;len; i++) &#123; data[i] = rand() % 100; &#125; return; &#125; void PrintList(int * data, int len) &#123; int i = 0; for (i=0; i&lt;len; i++) &#123; printf(\"%d \", data[i]); &#125; printf(\"\\n\"); return; &#125; // 直接插入排序 void InsertSort(int * data /* 待处理的数据 */, int len /* 数据的长度 */) &#123; int i = 0; for (i=1; i&lt;len; i++) &#123; // 从第二个数据开始处理 int j = i - 1; if (data[i] &lt; data[i - 1]) &#123; // 如果前面的序列存在比当前数值大的数 int temp = data[i]; while (j &gt;= 0 &amp;&amp; data[j] &gt; temp) &#123; // 一路往前把大的数向后移 data[j + 1] = data[j]; j--; &#125; data[j + 1] = temp; &#125; printf(\"%2d th sort: \", i); PrintList(data, len); &#125; return; &#125; int main(void) &#123; int * data = (int *)malloc(sizeof(int) * LENGTH); CreateList(data, LENGTH); printf(\"Before sort: \"); PrintList(data, LENGTH); InsertSort(data, LENGTH); printf(\"After sort: \"); PrintList(data, LENGTH); return 0; &#125; 希尔排序 希尔排序是直接插入排序的一种优化。其核心思想为： 将间隔为d的元素取出来看成一个新的子序列 对子序列进行直接插入排序，这样会使得原序列相对有序 不断缩小d的值，直到d等于1，此时希尔排序退化为直接插入排序 因为希尔排序每一次的排序都是建立在之前相对有序的基础上，所以能相对提高效率。 直接插入排序的空间复杂度为O(1)，且为不稳定的排序算法。 在增量序列函数选取合适的前提下，希尔排序的时间复杂度为O(n1.3)，最坏情况下的时间复杂度为O（n2）。 # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; # include &lt;time.h&gt; # define LENGTH 15 void CreateList(int * data, int len) &#123; int i = 0; srand(time(NULL)); for (i=0; i&lt;len; i++) &#123; data[i] = rand() % 100; &#125; return; &#125; void PrintList(int * data, int len) &#123; int i = 0; for (i=0; i&lt;len; i++) &#123; printf(\"%d \", data[i]); &#125; printf(\"\\n\"); return; &#125; // 希尔排序 void ShellSort(int * data, int len) &#123; int d = 0; int i = 0; for (d=len/2; d&gt;=1; d/=2) &#123; // 设置步长，初始值为元素个数的一半，最后的值为1 for (i=d; i&lt;len; i++) &#123; // 在规定的步长内对元素进行直接插入排序 if (data[i] &lt; data[i - d]) &#123; int temp = data[i]; int j = i - d; while (j &gt;= 0 &amp;&amp; data[j] &gt; temp) &#123; data[j + d] = data[j]; j = j - d; &#125; data[j + d] = temp; &#125; &#125; printf(\"d = %d: \", d); PrintList(data, len); &#125; return; &#125; int main(void) &#123; int * data = (int *)malloc(sizeof(int) * LENGTH); CreateList(data, LENGTH); printf(\"Before sort: \"); PrintList(data, LENGTH); ShellSort(data, LENGTH); printf(\"After sort: \"); PrintList(data, LENGTH); return 0; &#125;","categories":[{"name":"数据结构 - 排序","slug":"数据结构-排序","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"一个红包引发的惨案","slug":"一个红包引发的惨案","date":"2022-08-15T09:06:04.000Z","updated":"2022-08-15T09:27:54.668Z","comments":true,"path":"2022/08/15/一个红包引发的惨案/","link":"","permalink":"http://mythe51.github.io/2022/08/15/%E4%B8%80%E4%B8%AA%E7%BA%A2%E5%8C%85%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/","excerpt":"","text":"一个红包引发的惨案 故事起源于隔壁一个吹水群的某天中午，可能是想增加点乐趣，群主发了两个红包。恰好是一笔画红包。而一笔画红包涉及到数据结构图论的相关知识，所以在此进行总结，并贴出相关的代码。 简介 一笔画红包 一笔画红包是QQ红包的一种形式。挑战者需要完成一笔画挑战之后才能领取红包 欧拉图 欧拉图是一种特殊的图，定义如下： 欧拉图是指通过图（无向图或有向图）中所有边且每边仅通过一次通路，相应的回路称为欧拉回路。具有欧拉回路的图称为欧拉图（Euler Graph），具有欧拉通路而无欧拉回路的图称为半欧拉图。 对于欧拉图，有以下几条性质： 一个无向图存在欧拉回路，当且仅当该图有 0 个或 2 个奇数度数的顶点，且该图是连通图。 一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数，且该图是连通图。 一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。 一个有向图存在欧拉回路：图连通，所有节点的出度等于入度；或者除两个节点以外的其余节点的入度和出度都相等，且这两个节点一个满足出度 - 入度 ==1，另一个满足入度 – 出度 ==1。 对于QQ红包的场景，明显其为有向图。如果我们能获取到每条边的信息，就能使用深度优先算法求解欧拉路径。理论存在，实践开始 实践 获取边的信息 获取边的信息很简单，直接手机代理链接电脑上的fiddler，开启抓包即可。 右下角就是TX返回的包体了。connects数组包含了所有的边，而vertexes保存了所有的顶点。 对包体进行处理 这里使用了python对包进行处理，将包体的字符串变成我们熟悉的邻接矩阵： # 构建邻接矩阵 def PreProcess(package): global versum package = package.replace(\"\\\\\", \"\") package = package.replace(\"\\\"[\", \"[\") package = package.replace(\"]\\\"\", \"]\") package = json.loads(package)['data'] # 到这里为止是字符串的预处理 con = package['connects'] for i in con: sx = (i['x1'] - 75) / 150 sy = (i['y1'] - 75) / 150 ex = (i['x2'] - 75) / 150 ey = (i['y2'] - 75) / 150 # 根据像素计算顶点序号 s = int(sy * 5 + sx) e = int(ey * 5 + ex) versum = versum + 1 # 统计边的条数 m[s][e] = m[s][e] + 1 # 设置邻接矩阵 计算起始顶点和终止顶点 根据欧拉图的性质，对于任意一个合法的欧拉图，只可能出现两种情况： 有2个奇数度的顶点，此时这两个奇数度的顶点分别为起点和终点 没有奇数度的顶点，此时任意一个顶点都能作为起点和终点 根据性质，写出代码即可 求解欧拉路径 这里使用深度优先算法。欧拉图可能有多解，选择其中的一个解即可： # now 的初始调用值为上面确定的起点 def DFS(now): for i in range(25): if m[now][i] == 1: m[now][i] = m[now][i] - 1 DFS(i) path.append(now + 1) 完整代码 下面是完整代码： import json m = [[0 for j in range(25)] for i in range(25)] s = 0 e = 0 versum = 0 path = [] # 构建邻接矩阵 def PreProcess(package): global versum package = package.replace(\"\\\\\", \"\") package = package.replace(\"\\\"[\", \"[\") package = package.replace(\"]\\\"\", \"]\") print(package) package = json.loads(package)['data'] print(package[\"vertexes\"]) con = package['connects'] for i in con: sx = (i['x1'] - 75) / 150 sy = (i['y1'] - 75) / 150 ex = (i['x2'] - 75) / 150 ey = (i['y2'] - 75) / 150 s = int(sy * 5 + sx) e = int(ey * 5 + ex) versum = versum + 1 m[s][e] = m[s][e] + 1 # 判断起始和终止点 def GetStartAndEnd(): global s, e du = [] se = [] for i in range(25): t = sum(m[i]) t = t + sum([m[j][i] for j in range(25)]) du.append(t) print(\"顶点的度：\", du) for i in du: if i % 2 == 1: se.append(du.index(i)) if len(se) == 0: for i in du: if 1 != 0: se.append(du.index(i)) se.append(du.index(i)) break s = se[0] e = se[1] def DFS(now): for i in range(25): if m[now][i] == 1: m[now][i] = m[now][i] - 1 DFS(i) path.append(now + 1) pass if __name__ == '__main__': package = input(\"input package: \\n\") PreProcess(package) print(\"邻接矩阵：\") for i in range(25): print(m[i]) GetStartAndEnd() print(\"以下为分析结果：\\n\") print('起点：', s + 1, '终点：', e + 1, '边数：', versum) DFS(s) path.reverse() print(\"参考路径：\") for i in range(len(path)): print(path[i], end=' ') if (i+1) % 5 == 0: print() 运行截图： 希望能通过这个小小的例子，体会欧拉图在生活中的应用。","categories":[{"name":"数据结构 - 图-欧拉图","slug":"数据结构-图-欧拉图","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E6%AC%A7%E6%8B%89%E5%9B%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"构建一棵平衡二叉树","slug":"构建一棵平衡二叉树","date":"2022-08-04T14:14:02.000Z","updated":"2022-08-05T06:15:08.866Z","comments":true,"path":"2022/08/04/构建一棵平衡二叉树/","link":"","permalink":"http://mythe51.github.io/2022/08/04/%E6%9E%84%E5%BB%BA%E4%B8%80%E6%A3%B5%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"本篇从代码和图形两部分，深层次理解平衡二叉树的构造。 基本概念 首先给出二叉树节点的定义，以下均使用该处定义的节点类型： typedef struct avlnode &#123; int data; // 数据域 int height; // 以该节点为根的树的高度 struct avlnode * parent; // 父节点指针 struct avlnode * lchild; // 左孩子指针 struct avlnode * rchild; // 右孩子指针 &#125;Node, *AVLNode; 平衡二叉树是一种特殊的二叉排序树。既然是二叉排序树，就必须满足二叉排序树的性质： 所有左子树节点的值 &lt; 根节点的值 &lt; 所有右子树节点的值 对于一棵二叉排序树，我们在插入的时候只需要简单的寻找其插入位置，然后将其插入即可。代码表示如下： AVLNode pt = AVLTree; while(pt != NULL) &#123; if (pt-&gt;data &gt; val) &#123; pt = pt-&gt;lchild; &#125; else &#123; pt = pt-&gt;rchild; &#125; &#125; 根据此代码，pt最后停留的位置，就是新节点应该插入的位置。实际在写代码的时候肯定不会这样简单，因为单单有pt的位置还不能插入一个节点，需要有pt的父节点和插入节点相对于父节点的路径。这里不再赘述。 平衡二叉树和二叉树相比，引入了“平衡因子”这个概念，用来表示左右子树的高度之差。即： 平衡因子 = 左子树高度 - 右子树高度 // 计算平衡因子 int CalcBF(AVLNode node) &#123; if (node == NULL) &#123; return 0; // 空节点的平衡因子为0 &#125; int bf = 0; if (node-&gt;lchild != NULL) &#123; bf = bf + node-&gt;lchild-&gt;height; &#125; if (node-&gt;rchild != NULL) &#123; bf = bf - node-&gt;rchild-&gt;height; &#125; // bf = 0 + 左子树高度 - 右子树高度 = 左子树高度 - 右子树高度，这样做能尽量减少判断次数， return bf; &#125; 这里没加绝对值，表示平衡因子有正有负。事实上，平衡因子的正负反映了左右子树的高低关系：为正，表示左子树高于右子树；为负，表示右子树高于左子树。 基本操作–左旋和右旋 平衡二叉树规定，任意节点的平衡因子的绝对值不能超过1（即只能有0和1两种可能）。超过1就需要进行调整。调整只针对最小不平衡子树。以下介绍调整的两种方式：左旋，右旋。 左旋 左旋是使用右子树替代根的一种做法。如图所示： 在代码实现时，分为以下三步： 使用原根的右子树代替根的位置 将新根的左子树（如果存在）挂在原根的右子树上 将原根挂在新根的左子树上 以上步骤不可颠倒。完成之后，即可在实现原来根的右子树替换根的同时，不破坏左子树小于根小于右子树的原则。 以下是代码实现，代码中有详细的注解。 // 左旋 void lRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;rchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的左子树挂载到oldroot的右子树 oldroot-&gt;rchild = newroot-&gt;lchild; if (newroot-&gt;lchild != NULL) &#123; // 一定要加以判断，否则可能会产生访问错误 newroot-&gt;lchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;lchild = oldroot; oldroot-&gt;parent = newroot; // 这一步是防止传进来的参数本身就是根节点的情况 // 如果传进来的参数是根节点，就修改根节点指针指向的值，因为根节点没有父节点，无法通过修改父子节点的关系进行修改。 node = newroot; &#125; 右旋 右旋和左旋类似，是使用左子树替换根节点，同时保持二叉排序树特性不变的操作。直接上代码 // 右旋，这里使用了引用类型作为参数，方便修改 void rRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;lchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的右子树挂载到oldroot的左子树 oldroot-&gt;lchild = newroot-&gt;rchild; if (newroot-&gt;rchild != NULL) &#123; newroot-&gt;rchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;rchild = oldroot; oldroot-&gt;parent = newroot; node = newroot; &#125; 四种不平衡类型 有四种可能出现的导致不平衡的情形，分别是LL，RR，LR和RL（直接使用网图，懒得画了）： 这四种类型是根据新添加的节点相对于最小不平衡子树的位置而定的。例如，新添加的节点相对于最小不平衡子树的根节点，在左子树的右子树里，则为LR型。 LL型和RR型 LL型和RR型相对简单，只需要进行右旋和左旋即可，如图： LR型和RL型 这两种相对比较复杂，需要两步操作才能降低平衡因子。其核心思想是用最下面的节点，经过两次调整，替代原来的根节点，如图： 代码实现AVL树的生成 # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; typedef struct avlnode &#123; int data; // 数据域 int height; // 相对高度 struct avlnode * parent; // 父节点 struct avlnode * lchild; // 左孩子 struct avlnode * rchild; // 右孩子 &#125;Node, *AVLNode; // 计算相对高度，这里如果递归，必须使用后序递归，为什么？ void CalcHeight(AVLNode node) &#123; AVLNode pt = node; if (pt == NULL) &#123; return; &#125; CalcHeight(pt-&gt;lchild); CalcHeight(pt-&gt;rchild); int l = 1; int r = 1; if (node-&gt;lchild != NULL) &#123; l = node-&gt;lchild-&gt;height + 1; &#125; if (node-&gt;rchild != NULL) &#123; r = node-&gt;rchild-&gt;height + 1; &#125; node-&gt;height = l &gt; r ? l : r; &#125; // 计算平衡因子 int CalcBF(AVLNode node) &#123; if (node == NULL) &#123; return 0; &#125; int bf = 0; if (node-&gt;lchild != NULL) &#123; bf = bf + node-&gt;lchild-&gt;height; &#125; if (node-&gt;rchild != NULL) &#123; bf = bf - node-&gt;rchild-&gt;height; &#125; return bf; &#125; // 右旋 void rRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;lchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的右子树挂载到oldroot的左子树 oldroot-&gt;lchild = newroot-&gt;rchild; if (newroot-&gt;rchild != NULL) &#123; newroot-&gt;rchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;rchild = oldroot; oldroot-&gt;parent = newroot; node = newroot; &#125; // 左旋 void lRotate(AVLNode &amp; node) &#123; AVLNode oldroot = node; AVLNode newroot = node-&gt;rchild; AVLNode parent = node-&gt;parent; // 使用newroot替代原来位置 if (parent != NULL) &#123; if (parent-&gt;lchild == oldroot) &#123; parent-&gt;lchild = newroot; &#125; else &#123; parent-&gt;rchild = newroot; &#125; &#125; newroot-&gt;parent = parent; // 将newroot的左子树挂载到oldroot的右子树 oldroot-&gt;rchild = newroot-&gt;lchild; if (newroot-&gt;lchild != NULL) &#123; newroot-&gt;lchild-&gt;parent = oldroot; &#125; // 将oldroot挂载到newroot的右子树上 newroot-&gt;lchild = oldroot; oldroot-&gt;parent = newroot; node = newroot; &#125; void InsertNode(AVLNode &amp; AVLTree, int val) &#123; AVLNode pnew = (AVLNode)malloc(sizeof(Node)); pnew-&gt;data = val; pnew-&gt;lchild = pnew-&gt;rchild = pnew-&gt;parent = NULL; // 如果是空树，将该节点设为根节点，结束 if (AVLTree == NULL) &#123; AVLTree = pnew; return; &#125; // 非空树，先寻找插入的位置 AVLNode pt = AVLTree; AVLNode pp; int way = 0; while(pt != NULL) &#123; pp = pt; if (pt-&gt;data &gt; val) &#123; way = 0; pt = pt-&gt;lchild; &#125; else &#123; way = 1; pt = pt-&gt;rchild; &#125; &#125; pnew-&gt;parent = pp; if (way == 0) &#123; pp-&gt;lchild = pnew; &#125; else &#123; pp-&gt;rchild = pnew; &#125; CalcHeight(AVLTree); // 尝试找到最小的不平衡子树 pt = pnew; while (pt-&gt;parent != NULL) &#123; pt = pt-&gt;parent; if (CalcBF(pt) == 2) &#123; if (CalcBF(pt-&gt;lchild) == -1) &#123; lRotate(pt-&gt;lchild); &#125; if (pt == AVLTree) &#123; rRotate(AVLTree); &#125; else &#123; rRotate(pt); &#125; break; &#125; if (CalcBF(pt) == -2) &#123; if (CalcBF(pt-&gt;rchild) == 1) &#123; rRotate(pt-&gt;rchild); &#125; if (pt == AVLTree) &#123; lRotate(AVLTree); &#125; else &#123; lRotate(pt); &#125; break; &#125; &#125; CalcHeight(AVLTree); return; &#125; void PrintTree(AVLNode AVLTree) &#123; AVLNode pt = AVLTree; if (pt == NULL) &#123; return; &#125; PrintTree(pt-&gt;lchild); printf(\"%d %d\\n\", pt-&gt;data, pt-&gt;height); PrintTree(pt-&gt;rchild); &#125; int main(void) &#123; AVLNode Tree = NULL; int n = 0; int i = 0; int t = 0; scanf(\"%d\", &amp;n); for (i=0; i&lt;n; i++) &#123; scanf(\"%d\", &amp;t); InsertNode(Tree, t); &#125; PrintTree(Tree); return 0; &#125; 运行结果（上图为程序运行结果，下图为根据输入序列得到的二叉平衡树示意图）：","categories":[{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"记一次被骗经历","slug":"记一次被骗经历","date":"2022-07-27T07:32:11.000Z","updated":"2022-07-27T07:36:23.462Z","comments":true,"path":"2022/07/27/记一次被骗经历/","link":"","permalink":"http://mythe51.github.io/2022/07/27/%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A2%AB%E9%AA%97%E7%BB%8F%E5%8E%86/","excerpt":"","text":"记一次被骗经历 这并不是什么光彩的事，我知道。但是我还是想把它写出来，并放在一个（相对）比较显眼的位置，希望能对后来的人有所帮助。毕竟这样的学费交一次就够了。本篇文章会分为三个部分：被骗；发觉被骗以及追回被骗的钱。 0x01 医院门口的“偶遇” 那是7月24日的下午六点，我刚从医院出来。 当我正打算扫一辆单车回家的时候，有人向我搭话。大概的意思就是门店在做宣传投票，希望我能帮忙投其中的一个门店。 因为当时并不涉及金钱问题，加上投票只需要微信上简单操作即可。我就扫了当时他们提供的二维码，进入了投票页面。投票页面由于没有截图，就不放出来了。 投票之后，那个人提出投票可以参与免费的抽奖。当时觉得自己反正也不可能中，就抽了。出乎人意料的是，中了。页面显示“名牌手机名额一个”。 当时我觉得很不可思议，包括在场的工作人员也表现的很“不可思议”。提出“你的手气也太好了吧”，“如果真的领上了能不能请我们喝红牛”之类的话。我多次询问领取奖品是否需要支付额外的费用，他们都说不用。然后我就上了老板的电动车，到了店里。 — 在店里 — 在店里，工作人员先是简单的核实了一下我的抽奖是否是真实的。当然，速度很快，快到我不可思议（也就是几秒钟的时间就核实好了）。然后就说这个是真实的。 紧接着，他们和我核实了以下信息： 年满18周岁 是否是第一次参加店里的活动 芝麻信用分是否达到600分 全部核实完毕之后，他们向我展示了奖品——oppo a95（5G 8+256）/联想平板二选一。说实话，看到手机的时候我就觉得这个手机不咋地。但是多少也值点钱，如果将这个手机出二手还是能卖一点钱的。所以当时我选择要手机。 这时，重点来了。 他们给我打印好了活动的申请单。并且说，这是他们店正在搞的一个推广活动。现在主营线下的家用电器和手表（通过翻看宣传册得知手表均在1000元以上）。线上的app入驻的商家比较少。如果参加活动，需要给线上的app充值4999元（之后了解了我是学生，说只需要4000元即可）。 充值的钱会进入账户的“兑换余额”和“抵扣余额”，有以下几种消费方式： 线下店购买商品时，按照商品进行等额扣除 线上app有兑换商城，可以在兑换商城里兑换商品进行消费 线上app的“拼多多”，“京东”入口，可以使用余额部分抵扣商品原价，用户只需支付差价。 如果只进行到这个阶段，我肯定会因为身上没有5000块钱而选择放弃。然后就是第二个重点：不支持一次结清，只支持分期付款。并且给出了两种分期付款方案： 在未来的十年内，每个月到店结算当期账单（约40元每月） 使用花呗，借呗，京东白条或者其他分期付款软件，根据自己的信用额度选择分期时长（最长为2年，约每月140元） 以上两条是写在申请单上面的。之后还做出了口头约定（当然，同样不具备法律效力）。如： 店家承诺分期付款产生的利息由他们承担 店家承诺会帮我“套现”，即如果有人在实体店购买商品却不是会员，他们可以帮我将账户里的余额变现。 当时店里的音响声音被故意的开得很大。我觉得应该不是因为那些人喜欢音乐。 口头承诺的第二条让我有点心动。在之后我还是问了能不能再次降低套餐。工作人员“进行了请示”之后回复说，“手机的价值就接近2000，没办法再降低套餐了”，我便同意了。 （以下是签的协议文本） 在办理的时候，查了花呗借呗的额度均不足4000元，之后选择了乐花卡这个软件。这个软件利率相当之高，年化利率达到了24，而且还有其他的服务费之类。但是工作人员承诺会承担借贷利息。 这里有一个小插曲。在借贷时，因为操作失误，多借了一笔，也就是一共借了8000元。工作人员谎称是我的哥哥，帮我打客服，客服回应可以帮助解锁账单，2小时之后就可以提前还。（为之后埋下伏笔） 下载APP时，我首先在应用市场里面搜索。店家说，他们这个app只在IOS上架，未在安卓平台上架，要求我扫描他们提供的二维码下载。我不死心，百度搜索app名字，居然没搜到这个关键字。半信半疑中，扫描了他们提供的二维码下载了他们提供的app。 临走时，店家还“贴心”的送了一个充电宝，说是“本来是首次消费送的，就直接给你了”，估计是也没指望我来这里消费。 0x02 迟到的后知后觉 当天晚上回到家，我一夜没睡着。 想来想去，我也想不通为什么一定要让我使用分期软件进行支付。打开刚刚下载的“智家潮品”APP，启动图做的很烂，属于是一看就知道是次品的那种。简单浏览，发现里面可以兑换的商品种类还是很多的，就没有再理。 第二天（7月25日），我将手机挂在了咸鱼上，出价1300元（该配置的手机原价为1600元）。 当天第一个和我咨询的人重重的打了我一记大棒。 当时他和我讲价，我说1200元不包邮已经是底线，他也同意了，甚至已经付款了。但是最后，他提出要看看手机的激活日期。我当时的第一反应是，卧槽，还有这玩意？ 我开始搜索这个激活日期代表的含义。原来，安卓手机在首次联网开机的时候会被激活。这个激活时间是官方售后保修的依据。现实给了我一拳。因为官网显示这个手机早在2021年的5月就被激活，现在已经过保。 换句话说，这个手机早在一年前就被人联网使用过，很可能是退换机。这时候我开始意识到问题不对劲。想找店家要个说法： 这个时候感觉自己是被骗了。因为如果手机有这种情况的话，其他的电器也很可能会有类似的情况。花原价的钱，买到的已经是二手机器了。这时候我第一次意识到自己被骗了。 晚上，我和小A说我被骗了。被骂了一顿之后，我提出能不能把他那边的消费放到这个app上，帮我分担一点。他问了两样东西，一个是薯片，一个是可乐。 在那之后，我仔细的看了上面的食品类商品。发现里面虽然种类比较多，但是大多是不知名的小牌子，而且完全没有售后保障，也就是说，如果买到了临期或者过期的食品，只能自认倒霉。 与此同时，我将这个情况和小C（为什么不用B这个字母呢？因为觉得B这个字母不太好）说了，小C当即断定我被骗了。在了解到有分期付款的情况后，建议我直接报案。 经过一晚上的梳理，大致整理出以下几条不合理的地方： 诱导进行贷款消费 根据协议“注意事项”，主动退出需只能退还70%的金额，剩余金额在APP内无法取出，但是这笔钱扣除的没有根据。 作为赠品的手机非原装，提前一年就被使用过 第二天，当我和店家沟通，提出想看看原来的申请书和告知函时，被告知文件原版已经在签字当天被粉碎。更加印证了被骗的想法。 0x03 还算顺利的维权 此时是7月26日，距离被骗已经过去了两天。 下午两点，在和小C进行过充分的商量之后，我到了离我最近的辖区派出所。在和警察详细讲述了当时的情况之后，警察也一时没法分辨我是否已经被骗。因为此时还未到对方尽义务的时间，和我提出，要不就到被骗地点附近的派出所问问，要不就先等一个月。我选择了前者。 骑一辆单车，走了三公里，到了另一个派出所。 那个派出所的警察在听了我讲的之后，说当天在我之前已经有一个人有过同样的情况，让我去辖区的市监局（就在马路对面）。当时还是很高兴的，因为人越多代表这个事越容易解决。 在市监局门口站了一小会，有个人问我是不是举报智家潮品的，我说是，就进了办公室。 办公室里，那家店的老板已经在里面了，（接下来又是一顿被教育之后）现场办理了退款。在退款的时候，老板反复说“学生嘛，你和工作人员说就会全部给你退掉啦”之类的，我也反复说“我已经问过了，就是要预留百分之三十，所以我才来的”，大无语。 之所以不是3999，时因为当时收钱的时候就扣掉了前三个月的利息。我也表示如果能把当时收的前全部退还，分期付的利息我可以自己承担。就这样，只花了十几分钟就解决了问题，可喜可贺。 回家的路上，我和乐花卡的客服进行了沟通。客服在得知我是因为被骗借款之后，同意提前解锁订单还款。两小时之后成功还款，共计还款4012元。 还款之后，我将乐花卡，借呗，花呗，京东白条的账户全部注销，这件事情至此告一段落。 0x04 后记 从市监局出来之后，我在门口站了几分钟整理目前的信息。然后遇到了和我一样被骗的小D，我们在感叹自己是大冤种的同时，也从头到尾梳理了整次事件比较关键的细节点。 专挑独狼。因为多人很可能会被身边人提醒从而发现骗局 看你善良就会多捅几刀。对方正是利用助人为乐的心理，从而行骗 这次事件从头到尾我只交了16块钱的学费，但是间接的损失不可估量。包括对心理产生的影响以及两天没好好吃饭睡觉。刚开始发觉这是骗局的时候，心里是很无助的。但是经过和朋友沟通（对，没找家长）之后。。还是很无助（）。 总之，希望我的经历能给更多的人起到警示作用，虽然最后并没有直接损害很多，但是也仅仅是偶然情况，下一次肯定就不止这点损失了。","categories":[{"name":"杂记","slug":"杂记","permalink":"http://mythe51.github.io/categories/%E6%9D%82%E8%AE%B0/"}],"tags":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]},{"title":"顺序查找","slug":"顺序查找","date":"2022-07-23T12:42:11.000Z","updated":"2022-07-23T12:48:25.837Z","comments":true,"path":"2022/07/23/顺序查找/","link":"","permalink":"http://mythe51.github.io/2022/07/23/%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE/","excerpt":"","text":"根据王道教材编写的顺序查找的代码。顺序查找的思路比较简洁，但是需要注意哨兵的使用方法。 /* 时间：2022年7月23日20:42:30 作者：Mythe 根据王道书上的代码，写的顺序查找的示例。 在本例中注意理解哨兵的作用。 哨兵不能让程序运行更快，但是能简化思考的逻辑，减少if语句的使用。 */ # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; # include &lt;time.h&gt; typedef struct &#123; int * elem; int length; &#125;L, *SeqList; // 顺序查找 int SeqSearch(SeqList L, int key) &#123; int i = L-&gt;length - 1; // 初始指针指向末尾 L-&gt;elem[0] = key; // 0号位置放哨兵 while (L-&gt;elem[i] != key) &#123; // 即使待查找的表里面没有指定关键字，也必定会在0号位置找到指定关键字 i--; // 从后往前依次找 &#125; return i - 1; // 返回非-1的数表示查找成功，否则查找失败 &#125; // 填充数据 void InitList(SeqList L) &#123; srand(time(NULL)); L-&gt;length = 1; L-&gt;elem = (int *)malloc(sizeof(int) * 11); L-&gt;elem[0] = 0; // 第一个位置为无效数据 int i = 0; for (i=0; i&lt;10; i++) &#123; L-&gt;elem[L-&gt;length] = rand() % 100; L-&gt;length++; &#125; &#125; // 导出数据 void PrintList(SeqList L) &#123; int i = 0; for (i=1; i&lt;L-&gt;length; i++) &#123; printf(\"%d \", L-&gt;elem[i]); &#125; printf(\"\\n\"); &#125; int main(void) &#123; int key = 0; SeqList L = (SeqList)malloc(sizeof(SeqList)); InitList(L); printf(\"------ 顺序查找演示程序 ------\\n待查找数组：\"); PrintList(L); printf(\"输入要查找的关键字：\"); scanf(\"%d\", &amp;key); printf(\"您查找的关键字所在的数组下标为%d\\n若数组下标为-1则查找失败。\\n\", SeqSearch(L, key)); return 0; &#125; 运行截图：","categories":[{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"折半查找","slug":"折半查找","date":"2022-07-22T13:16:37.000Z","updated":"2022-07-23T14:04:46.685Z","comments":true,"path":"2022/07/22/折半查找/","link":"","permalink":"http://mythe51.github.io/2022/07/22/%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE/","excerpt":"","text":"根据王道教材编写的折半查找的示例代码。 折半查找的题目示例： P2249 /* 时间：2022年7月22日21:06:51 作者：Mythe 根据王道书上的代码，写的折半查找的示例代码。 */ # include &lt;stdio.h&gt; # include &lt;stdlib.h&gt; typedef struct List &#123; int * data; int length; &#125;List, *SeqList; // 将数据初始化为从0到1000 void InitList(SeqList L) &#123; L-&gt;data = (int *)malloc(sizeof(int) * 1001); L-&gt;length = 0; int i = 0; for (i=0; i&lt;1000; i++) &#123; L-&gt;data[L-&gt;length] = i + 1; L-&gt;length++; &#125; return; &#125; int BinarySearch(SeqList L, int key) &#123; int i = 0; int low = 0, high = L-&gt;length - 1; int middle = 0; while (low &lt;= high) &#123; middle = (low + high) / 2; // 计算middle的值为两者中心 int val = L-&gt;data[middle]; printf(\"第%2d次比较，low=%3d，high=%3d，middle=%3d，数值：%3d，结果：\", i++, low, high, middle, L-&gt;data[middle]); if (val &lt; key) &#123; low = middle + 1; // 如果给定的值比当前中心位置大，则让low指针指向middle的下一个位置 &#125; else if (val &gt; key) &#123; high = middle - 1; // 如果给定的值比当前中心位置小，则让high指针指向middle的上一个位置 &#125; else &#123; printf(\"成功。\\n\"); return middle; &#125; printf(\"失败。\\n\"); &#125; // 当low的值大于high的值时，while循环退出，此时说明没有查找到目标的值，返回-1。 return -1; &#125; int main(void) &#123; int key; SeqList L = (SeqList)malloc(sizeof(List)); printf(\"----- 折半查找演示程序 ------\\n\"); printf(\"顺序表存放1-1000之间的整数，请输入你要查找的数：\"); InitList(L); scanf(\"%d\", &amp;key); printf(\"index = %d\\n\", BinarySearch(L, key)); return 0; &#125; 运行截图：","categories":[{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"}]},{"title":"米游社api相关","slug":"米游社api相关","date":"2022-05-09T11:00:00.000Z","updated":"2022-05-11T04:03:23.236Z","comments":true,"path":"2022/05/09/米游社api相关/","link":"","permalink":"http://mythe51.github.io/2022/05/09/%E7%B1%B3%E6%B8%B8%E7%A4%BEapi%E7%9B%B8%E5%85%B3/","excerpt":"","text":"请求规范（请求头） 字段 说明 参考值（无特殊需求可以照抄） x-rpc-app_version 米游社app版本 2.11.1 User-Agent UA字段 Mozilla/5.0 AppleWebKit/605.1.15 (KHTML, like Gecko) miHoYoBBS/2.11.1 x-rpc-client_type 客户端类型 5 Referer Referer字段 https://webstatic.mihoyo.com/ Cookie 米游社Cookie 浏览器登录米游社，F12找到控制台，输入&quot;document.cookie&quot;回车即可，如下图 DS 动态密钥 生成方法如下 动态密钥 动态密钥由3部分构成，最后一部分是一个MD5。MD5的输入由5个部分构成，按照如下格式进行组合： data = f&quot;salt=&#123;CN_DS_SALT&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;&quot; 参数说明： 参数 含义 CN_DS_SALT 盐，在当前版本的米游社app里这个值是“xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs” t 时间戳 r 一个从100000到200000的随机数 b POST请求的数据，需要将字典对象序列化 q GET请求的数据，形如&quot;aaa=aaa&amp;bbb=bbb&amp;ccc=ccc&quot; 伪代码如下： data = &quot;salt=&#123;CN_DS_SALT&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;&quot; md5data = md5(data) DS = &quot;&#123;t&#125;,&#123;r&#125;,&#123;h&#125;&quot; 给出两种实现方式： python（@heartalborada） CN_DS_SALT = 'xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs' def generate_cn_ds(body = None, query = None) -&gt; str: ''' Body: POST请求 query: GET请求 ''' t = int(time.time()) r = random.randint(100001, 200000) b = json.dumps(body) if body else \"\" q = \"&amp;\".join(f\"&#123;k&#125;=&#123;v&#125;\" for k, v in sorted(query.items())) if query else \"\" h = hashlib.md5(f\"salt=&#123;CN_DS_SALT&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;\".encode()).hexdigest() return f\"&#123;t&#125;,&#123;r&#125;,&#123;h&#125;\" C#（@DGP-Studio） using Snap.Data.Json; using Snap.Data.Utility; using System; using System.Linq; public class DynamicSecretProvider2 : Md5Converter &#123; private static readonly string APISalt = \"xV8v4Qu54lUKrEYFZkJhB8cuOh9Asafs\"; public static string Create(string queryUrl, object? postBody = null) &#123; long t = DateTimeOffset.UtcNow.ToUnixTimeSeconds(); string r = GetRandomString(); string b = postBody is null ? \"\" : Json.Stringify(postBody); string q = \"\"; string[] urlParts = queryUrl.Split('?'); if (urlParts.Length == 2) &#123; string[] queryParams = urlParts[1].Split('&amp;').OrderBy(x =&gt; x).ToArray(); q = string.Join(\"&amp;\", queryParams); &#125; string check = GetComputedMd5($\"salt=&#123;APISalt&#125;&amp;t=&#123;t&#125;&amp;r=&#123;r&#125;&amp;b=&#123;b&#125;&amp;q=&#123;q&#125;\"); return $\"&#123;t&#125;,&#123;r&#125;,&#123;check&#125;\"; &#125; private static readonly Random random = new(); private static string GetRandomString() &#123; return random.Next(100000, 200000).ToString(); &#125; &#125; API UID 查询玩家基本信息 url：https://api-takumi-record.mihoyo.com/game_record/app/genshin/api/index 请求方式：GET 传入字段 说明 值 role_id 玩家UID 如“100010000” server 玩家所在服务器 “cn_gf01”国服官服，“cn_qd01”国服B服 获取角色武器和圣遗物 url：https://api-takumi-record.mihoyo.com/game_record/app/genshin/api/character 请求方式：POST 传入字段 说明 值 character_ids 要查询的角色id 传入空数组即可，即 []，可获取全部角色 role_id 玩家UID 如“100010000” server 玩家所在服务器 “cn_gf01”国服官服，“cn_qd01”国服B服 获取档期和上期角色数据 url：https://api-takumi-record.mihoyo.com/game_record/app/genshin/api/spiralAbyss 请求方式：GET 传入字段 说明 值 role_id 玩家UID 如“100010000” server 玩家所在服务器 “cn_gf01”国服官服，“cn_qd01”国服B服 schedule_type 档期类型 “1”为本期，“2”为上期","categories":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/categories/%E9%BB%98%E8%AE%A4/"}],"tags":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]},{"title":"abccc","slug":"abccc","date":"2022-04-21T07:25:36.000Z","updated":"2022-04-21T07:26:47.606Z","comments":true,"path":"2022/04/21/abccc/","link":"","permalink":"http://mythe51.github.io/2022/04/21/abccc/","excerpt":"","text":"this is a test blog","categories":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/categories/%E9%BB%98%E8%AE%A4/"}],"tags":[{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-04-21T04:50:44.934Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2022/04/21/hello-world/","link":"","permalink":"http://mythe51.github.io/2022/04/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post $ hexo new \"My New Post\" More info: Writing Run server $ hexo server More info: Server Generate static files $ hexo generate More info: Generating Deploy to remote sites $ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"计算机组成原理 - 中央处理器","slug":"计算机组成原理-中央处理器","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"name":"计算机组成原理 - 数据的表示和运算","slug":"计算机组成原理-数据的表示和运算","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97/"},{"name":"计算机网络 - 计算机网络体系结构","slug":"计算机网络-计算机网络体系结构","permalink":"http://mythe51.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"杂记","slug":"杂记","permalink":"http://mythe51.github.io/categories/%E6%9D%82%E8%AE%B0/"},{"name":"数据结构 - 排序","slug":"数据结构-排序","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%8E%92%E5%BA%8F/"},{"name":"数据结构 - 图-欧拉图","slug":"数据结构-图-欧拉图","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE-%E6%AC%A7%E6%8B%89%E5%9B%BE/"},{"name":"数据结构 - 查找","slug":"数据结构-查找","permalink":"http://mythe51.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/"},{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/categories/%E9%BB%98%E8%AE%A4/"}],"tags":[{"name":"考研408","slug":"考研408","permalink":"http://mythe51.github.io/tags/%E8%80%83%E7%A0%94408/"},{"name":"默认","slug":"默认","permalink":"http://mythe51.github.io/tags/%E9%BB%98%E8%AE%A4/"}]}